<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++笔记</title>
    <url>/2023/02/23/CppLearn/</url>
    <content><![CDATA[<h1 id="一-c介绍"><a class="markdownIt-Anchor" href="#一-c介绍">#</a> 一、C++ 介绍</h1>
<p>C++(C Plus Plus)，是由微软 (Microsoft) 公司基于 C 语言扩充编写的一门语言。</p>
<p>C++ 是一门面向对象的语言</p>
<p>其中大部分语法与 C 语言相似，可以参考 C 语言笔记。</p>
<h1 id="二-c语法"><a class="markdownIt-Anchor" href="#二-c语法">#</a> 二、C++ 语法</h1>
<h2 id="1注释"><a class="markdownIt-Anchor" href="#1注释">#</a> 1. 注释</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="2if-while-switch等结构请参考c语言笔记"><a class="markdownIt-Anchor" href="#2if-while-switch等结构请参考c语言笔记">#</a> 2.if、while、switch 等结构请参考 C 语言笔记</h2>
<h2 id="3指针请参考c语言笔记"><a class="markdownIt-Anchor" href="#3指针请参考c语言笔记">#</a> 3. 指针请参考 C 语言笔记</h2>
<h2 id="4const修饰词对指针的使用"><a class="markdownIt-Anchor" href="#4const修饰词对指针的使用">#</a> 4.const 修饰词对指针的使用</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.const修饰指针  --常量指针</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="comment">//特点：指针的指向可以改，指针指向的值不可以改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.const修饰常量  --指针常量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;a;</span><br><span class="line"><span class="comment">//特点：指针的指向不可以改，指针指向的值可以改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.const既修饰指针，又修饰常量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p = &amp;a;</span><br><span class="line"><span class="comment">//特点：指针的指向和指针指向的值都不可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰词可以在函数之间传递地址时，锁定数据，防止误操作</span></span><br></pre></td></tr></table></figure>
<h2 id="5结构体"><a class="markdownIt-Anchor" href="#5结构体">#</a> 5. 结构体</h2>
<p><mark><strong>使用结构体指针调用结构体内成员时，使用 -&gt;。</strong></mark></p>
<p><strong>如：struct student s = {data , data , data};</strong></p>
<p><em><em>student</em> p = &amp;s;</em>*</p>
<p><strong>p-&gt;data</strong></p>
<p><mark><strong>结构体基础语法等请参考 C 语言笔记</strong></mark></p>
<h2 id="6堆区开辟数据new关键字"><a class="markdownIt-Anchor" href="#6堆区开辟数据new关键字">#</a> <mark>6. 堆区开辟数据 (new 关键字)</mark></h2>
<p><strong>使用<mark> new</mark> 关键字开辟堆区数据，使用<mark> delete</mark> 关键字进行释放</strong></p>
<p><strong>注意：开辟的堆区需要程序员手动释放</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用： new type</span></span><br><span class="line">    <span class="type">int</span>* example = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; *example &lt;&lt; endl;<span class="comment">//打印10</span></span><br><span class="line">    <span class="keyword">delete</span> example;<span class="comment">//将example释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* example = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//创建一个长度为10的整型数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)<span class="comment">//遍历数组赋值</span></span><br><span class="line">        example[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)<span class="comment">//遍历数组打印</span></span><br><span class="line">        cout &lt;&lt; example[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] example;<span class="comment">//释放数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7引用起别名"><a class="markdownIt-Anchor" href="#7引用起别名">#</a> 7. 引用 (起别名)</h2>
<h3 id="1使用"><a class="markdownIt-Anchor" href="#1使用">#</a> (1) 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="comment">//数据类型 &amp;别名 = 原名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b = a;</span><br><span class="line">    <span class="comment">//相当于新建一个指针，将a的地址赋给新指针</span></span><br><span class="line">    <span class="comment">//注意：1.引用必须初始化 2.引用初始化后不可改变</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(a,c);<span class="comment">//引用传递类似于地址传递，能修改原数据</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">//a与c的值会交换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> &amp;test01 = <span class="built_in">test</span>();<span class="comment">//返回number，其别名为test01</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test01=&quot;</span> &lt;&lt; test01 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">test</span>() = <span class="number">1000</span>;<span class="comment">//因返回的是number，所以可以对number进行赋值</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test01=&quot;</span> &lt;&lt; test01 &lt;&lt; endl;<span class="comment">//对number赋值后，其引用test01的值也会改变</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;<span class="comment">//引用传递类似于地址传递，能修改原数据</span></span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：不要返回局部变量，或者返回局部变量的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数可以作为左值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2本质"><a class="markdownIt-Anchor" href="#2本质">#</a> (2) 本质</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用的本质就是指针常量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = a;</span><br><span class="line"><span class="comment">//实际操作为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="comment">//指针常量的指向不可改变，所以引用不可更改</span></span><br><span class="line">ref = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//实际操作为 *ref = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;<span class="comment">//实际操作为 int* const ref = &amp;a;</span></span><br><span class="line">    ref = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8函数"><a class="markdownIt-Anchor" href="#8函数">#</a> <mark>8. 函数</mark></h2>
<p><mark><strong>函数基础参考 C 语言笔记</strong></mark></p>
<h3 id="1形参默认值与占位参数"><a class="markdownIt-Anchor" href="#1形参默认值与占位参数">#</a> <mark>(1) 形参默认值与占位参数</mark></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++函数的形参可以设定默认值，如</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">example</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c = <span class="number">20</span>,<span class="type">int</span> d = <span class="number">30</span>)</span></span>&#123;<span class="comment">//注意：有默认值的形参必须置后(写在最右边)</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;<span class="comment">//注意2：函数的声明与实现，仅能出现一次默认值设定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">example</span>(<span class="number">10</span>,<span class="number">10</span>) &lt;&lt; endl;<span class="comment">//打印40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数占位参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//其中第二个int起到占位作用</span></span><br><span class="line">    <span class="comment">//若有占位参数，则调用该函数时，需输入参数才可以调用。如func(10,10);</span></span><br><span class="line">    <span class="comment">//占位参数可以有默认参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2函数重载"><a class="markdownIt-Anchor" href="#2函数重载">#</a> <mark>(2) 函数重载</mark></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载可以让函数名相同，提高复用性</span></span><br><span class="line"><span class="comment">//函数重载要求条件</span></span><br><span class="line"><span class="comment">//1.同一个作用域下</span></span><br><span class="line"><span class="comment">//2.函数名相同</span></span><br><span class="line"><span class="comment">//3.函数参数类型不同，或个数不同，或顺序不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="comment">//参数个数不同</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span>&#123;<span class="comment">//参数类型不同</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(double a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a,double b)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="comment">//参数顺序不同</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(double a,int b)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：函数重载碰到默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2(int a,int b = 10)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于以上写法，使用func2(10)；调用函数时，会同时触发两种情况，导致错误</span></span><br></pre></td></tr></table></figure>
<h2 id="9类与对象"><a class="markdownIt-Anchor" href="#9类与对象">#</a> <mark>9. 类与对象</mark></h2>
<p>C++ 面向对象的三大特性：<mark><strong>封装、继承、多态</strong></mark></p>
<p>C++ 认为万事万物皆对象，对象上有其属性和行为</p>
<h3 id="1封装"><a class="markdownIt-Anchor" href="#1封装">#</a> (1) 封装</h3>
<p>封装的意义：</p>
<p><mark><strong>1. 将属性和行为作为一个整体，表现生活中的事物</strong></mark></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例(写一个圆类)：</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//属性 = 成员属性 = 成员变量</span></span><br><span class="line">    <span class="type">int</span> c_r;<span class="comment">//半径</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * PI * c_r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Circle c1;<span class="comment">//创建对象(实例化)</span></span><br><span class="line">    c1.c_r = <span class="number">10</span>;<span class="comment">//给圆类的属性赋值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的周长为:&quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;<span class="comment">//调用圆类的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2(学生类):</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//公共权限</span></span><br><span class="line">    string s_name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> s_id;<span class="comment">//学号</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span></span>&#123;<span class="comment">//打印学生信息的方法</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; s_name &lt;&lt; <span class="string">&quot;学号:&quot;</span> &lt;&lt; s_id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123;<span class="comment">//修改姓名的方法</span></span><br><span class="line">        s_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;<span class="comment">//修改学号的方法</span></span><br><span class="line">        s_id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark><strong>2. 将属性和行为加以权限控制</strong></mark></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//权限分为三种</span></span><br><span class="line"><span class="comment">//public	成员 类内可以访问，类外也可以访问</span></span><br><span class="line"><span class="comment">//protected 成员 类内可以访问，类外不可以访问。子类可以访问。</span></span><br><span class="line"><span class="comment">//private	成员 类内可以访问，类外不可以访问。子类不可以访问。</span></span><br></pre></td></tr></table></figure>
<p><strong>struct 与 class 的区别：struct 的默认权限为 public，class 默认权限为 private</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span>&#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C1 c1;</span><br><span class="line">    <span class="comment">//c1.a = 100;//这行代码是不被允许的，因为class的默认权限为private</span></span><br><span class="line">    C2 c2;</span><br><span class="line">    c2.b = <span class="number">100</span>;<span class="comment">//这行代码是被允许的，因为struct的默认权限为public</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2构造函数与析构函数"><a class="markdownIt-Anchor" href="#2构造函数与析构函数">#</a> (2) 构造函数与析构函数</h3>
<p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。</p>
<p>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</p>
<p><strong>C++ 会自动提供构造函数 (空实现) 与析构函数 (空实现) 与拷贝构造函数。</strong></p>
<p>当拥有构造函数 (有参) 时，C++ 将不再自动提供无参空实现，但仍提供拷贝构造函数。</p>
<p>当拥有拷贝构造函数时，C++ 不再自动提供其他构造函数。</p>
<p><mark><strong>构造函数语法：</strong></mark></p>
<p>1. 构造函数没有返回值，也不写 void。</p>
<p>2. 函数名与类名相同。</p>
<p>3. 构造函数可以有参数，因此可以发生重载。</p>
<p>4. 程序在调用对象时会自动调用构造函数，无需手动调用，而且只会调用一次。</p>
<p>==<strong> 析构函数语法：=</strong>=</p>
<p>1. 析构函数没有返回值，也不写 void。</p>
<p>2. 函数名与类名相同，函数名前要添加～</p>
<p>3. 析构函数不可以有参数，因此不能重载。</p>
<p>4. 程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassLearn</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ClassLearn</span>();</span><br><span class="line">	~<span class="built_in">ClassLearn</span>();</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span>* height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ClassLearn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ClassLearn::<span class="built_in">ClassLearn</span>() &#123;</span><br><span class="line">    age = <span class="number">18</span>;</span><br><span class="line">    height = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">175</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassLearn::~<span class="built_in">ClassLearn</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (height != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> height;</span><br><span class="line">        height = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>拷贝构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">        <span class="comment">//拷贝构造函数，实例化一个类，并将新的实例按照传入的实例复制所有属性</span></span><br><span class="line">        age = p.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3深拷贝与浅拷贝"><a class="markdownIt-Anchor" href="#3深拷贝与浅拷贝">#</a> (3) 深拷贝与浅拷贝</h3>
<p><strong>浅拷贝：</strong></p>
<p>编译器提供的拷贝构造函数，仅进行浅拷贝操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* age;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (age != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> age;</span><br><span class="line">            age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当其中 p2 对 p1 进行拷贝时，p2 的 int* age 仅仅拷贝了 p1 中 age 的地址。</p>
<p>最后结束时，p2<sub> (栈后进先出)</sub> 调用析构函数，释放了 age 指向的堆区内存。</p>
<p>p1 再调用析构函数，则会出现错误。</p>
<p><strong>若要解决浅拷贝的不足，则需重写拷贝构造函数进行深拷贝：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//例如</span><br><span class="line">class Person()&#123;</span><br><span class="line">    public:</span><br><span class="line">    int* age;</span><br><span class="line">    Person(int age)&#123;</span><br><span class="line">        this-&gt;age = new int(age);</span><br><span class="line">    &#125;</span><br><span class="line">    Person(const Person &amp;p)&#123;</span><br><span class="line">    	this-&gt;age = new int(*p.age);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()&#123;</span><br><span class="line">        if (age != NULL)&#123;</span><br><span class="line">            delete age;</span><br><span class="line">            age = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Person p1(18);</span><br><span class="line">    Person p2(p1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4初始化列表"><a class="markdownIt-Anchor" href="#4初始化列表">#</a> (4) 初始化列表</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以通过以下形式，使用构造函数来初始化对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    string m_pName;</span><br><span class="line">    <span class="built_in">Phone</span>(string pName):<span class="built_in">m_pName</span>(pName)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Phone phone;</span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="type">int</span> age):<span class="built_in">age</span>(age),<span class="built_in">name</span>(name)&#123;</span><br><span class="line">        <span class="comment">//当类A的成员中包含类B时，实例化一个类A，会首先实例化类B，再实例化类A。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5静态成员"><a class="markdownIt-Anchor" href="#5静态成员">#</a> (5) 静态成员</h3>
<p>在成员变量或成员函数添加<mark> static</mark> 关键字，称为静态成员</p>
<p>静态成员分为：</p>
<p><strong>静态成员变量：1. 所有对象共享一份数据，2. 在编译阶段分配内存，3. 类内声明，类外初始化。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类内声明，类外初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:<span class="comment">//静态成员也有访问权限</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> age;<span class="comment">//类内声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::age = <span class="number">18</span>;<span class="comment">//类外初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量可以通过类名直接访问(如果访问权限是public)</span></span><br><span class="line">    cout &lt;&lt; Person::age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态成员函数：1. 所有对象共享同一个函数，2. 静态成员函数只能访问静态成员变量。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:<span class="comment">//静态成员也有访问权限</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        name = <span class="string">&quot;张三&quot;</span>;<span class="comment">//这个语句是错误的，静态成员函数不能访问非静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态成员函数可以通过类名直接访问(如果访问权限是public)</span></span><br><span class="line">    Person::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6成员变量与成员函数分开存储"><a class="markdownIt-Anchor" href="#6成员变量与成员函数分开存储">#</a> (6) 成员变量与成员函数分开存储</h3>
<p>1. 空对象占用 1 个字节。</p>
<p>2. 成员变量占用的空间，即为对象占用的空间。</p>
<p>3. 静态成员变量并不存储在对象上。</p>
<p>4. 成员函数并不存储在对象上。</p>
<h3 id="7this指针"><a class="markdownIt-Anchor" href="#7this指针">#</a> (7) this 指针</h3>
<p>this 指针无需定义，可直接使用。</p>
<p>this 指针是隐含每一个非静态成员函数内的一种指针。</p>
<p>this 指针指向 被调用的成员函数所属的对象。</p>
<p>用途：</p>
<p>当形参和成员变量同名时，可使用 this 区分。</p>
<p>在类的非静态成员函数中，返回对象本身，可以使用 return *this;</p>
<h3 id="8const修饰成员函数"><a class="markdownIt-Anchor" href="#8const修饰成员函数">#</a> (8) const 修饰成员函数</h3>
<p>成员函数后添加加 const 修饰，被称为常函数</p>
<p>常函数内不可以修改成员属性。</p>
<p>成员属性声明时使用 mutable 修饰，则可以在常函数中修改。</p>
<p>常对象：</p>
<p>声明对象前加 const 修饰，则称为常对象。</p>
<p>常对象只能调用常函数。</p>
<h3 id="9友元"><a class="markdownIt-Anchor" href="#9友元">#</a> (9) 友元</h3>
<p>作用：允许类外一些特殊的函数或类访问一些私有成员。</p>
<p>关键字：friend</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">House</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGuy</span><span class="params">(House* house)</span></span>;<span class="comment">//则使用全局函数goodGuy时，就能访问m_BedRoom;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">myFriend</span>;<span class="comment">//友元类</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">myFriend::visit</span><span class="params">()</span></span>;<span class="comment">//友元成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myFriend</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="10运算符重载"><a class="markdownIt-Anchor" href="#10运算符重载">#</a> <mark>(10) 运算符重载</mark></h3>
<h4 id="101加号运算符重载"><a class="markdownIt-Anchor" href="#101加号运算符重载">#</a> (10.1) 加号运算符重载</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age = <span class="number">10</span>):<span class="built_in">age</span>(age)&#123;&#125;</span><br><span class="line">    Person <span class="keyword">operator</span>+ (Person&amp; p) &#123;</span><br><span class="line">        Person temp;</span><br><span class="line">        temp.age = <span class="keyword">this</span>-&gt;age + p.age;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    Person p3 = p1 + p2;</span><br><span class="line">    cout &lt;&lt; p3.age &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述代码实现了对+运算符的重载，使得main中可以将p1与p2相加。</span></span><br><span class="line"><span class="comment">//也可以使用全局函数实现运算符重载，如下：</span></span><br><span class="line">Person <span class="keyword">operator</span>+ (Person &amp;p1, Person &amp;p2)&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.age = p1.age + p2.age;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：对于内置的数据类型(int之类的)的表达式的运算符是无法改变的</span></span><br><span class="line"><span class="comment">//注2：不要滥用运算符重载</span></span><br></pre></td></tr></table></figure>
<h4 id="102左移运算符重载"><a class="markdownIt-Anchor" href="#102左移运算符重载">#</a> (10.2) 左移运算符重载</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如下：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="built_in">Person</span>(string name = <span class="string">&quot;张三&quot;</span>, <span class="type">int</span> age = <span class="number">10</span>) :<span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person&amp; p) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_name=&quot;</span> &lt;&lt; p.m_name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;m_age=&quot;</span> &lt;&lt; p.m_age;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;<span class="comment">//通常使用全局函数重载左移运算符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出结果为：</span></span><br><span class="line">    <span class="comment">//m_name=张三</span></span><br><span class="line">    <span class="comment">//m_age=18</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="103递增运算符重载"><a class="markdownIt-Anchor" href="#103递增运算符重载">#</a> (10.3) 递增运算符重载</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如下：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回引用，保证一直对一个目标进行操作，便于实现链式操作</span></span><br><span class="line">    MyInt&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用int作为占位符，来区分前置++与后置++。</span></span><br><span class="line">    <span class="comment">//此时编译器会将下面这个重载识别为后置++的重载</span></span><br><span class="line">    MyInt <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">//注意，这种写法不可以链式后置++(指：(myInt++)++)</span></span><br><span class="line">        <span class="function">MyInt <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> num = <span class="number">10</span>):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInt myInt) &#123;</span><br><span class="line">    cout &lt;&lt; myInt.num;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyInt <span class="title">myInt</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; (myInt++)++ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="104赋值运算符重载"><a class="markdownIt-Anchor" href="#104赋值运算符重载">#</a> (10.4) 赋值运算符重载</h4>
<p>C++ 编译器提供的赋值运算，仅做浅拷贝。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* num;</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> data)&#123;</span><br><span class="line">        num = <span class="keyword">new</span> <span class="built_in">int</span>(data); </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Example</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> num;</span><br><span class="line">            num = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Example <span class="title">e1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Example <span class="title">e2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    e2 = e1;</span><br><span class="line">    cout &lt;&lt; *e1.num &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *e2.num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为仅做浅拷贝，所以当e2 = e1时，e2的num仅copy了e1的num存储的地址</span></span><br><span class="line"><span class="comment">//当e1使用完析构之后，num存储的地址被delete。</span></span><br><span class="line"><span class="comment">//则e2再进行delete会导致报错。</span></span><br><span class="line"><span class="comment">//在成员函数中添加如下代码，来重载赋值运算符</span></span><br><span class="line">Example&amp; <span class="keyword">operator</span>=(Example&amp; e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> num;</span><br><span class="line">            num = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="keyword">new</span> <span class="built_in">int</span>(*e.num);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="105关系运算符重载"><a class="markdownIt-Anchor" href="#105关系运算符重载">#</a> (10.5) 关系运算符重载</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="built_in">Person</span>(string name,<span class="type">int</span> age):<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)&#123;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name == p.name &amp;&amp; <span class="keyword">this</span>-&gt;age == p.age)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name == p.name &amp;&amp; <span class="keyword">this</span>-&gt;age == p.age)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1与p2是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;p1与p2是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="106重载函数运算符"><a class="markdownIt-Anchor" href="#106重载函数运算符">#</a> (10.6) 重载函数运算符</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//将()重载</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;<span class="comment">//这种重载方式类似于函数，因此被称为仿函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyAdd myAdd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11继承"><a class="markdownIt-Anchor" href="#11继承">#</a> (11) 继承</h3>
<h4 id="111继承语法与权限"><a class="markdownIt-Anchor" href="#111继承语法与权限">#</a> (11.1) 继承语法与权限</h4>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FatherClass</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span>:<span class="keyword">public</span> FatherClass&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继承可以用于减少重复代码，子类可以从父类那里继承相同的代码部分。</p>
<p>继承方式分为三种：</p>
<p>public：公共继承，无法访问 private，继承的成员权限与父类相同</p>
<p>protected：保护继承，无法访问 private，继承的的成员权限变为 protected。</p>
<p>private：私有继承，无法访问 private，继承的成员权限变为 private。</p>
<p>注：继承时仍然继承 private 成员，只是无法访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> hp;</span><br><span class="line">	<span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solid</span> :<span class="keyword">public</span> Enemy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Solid</span>(<span class="type">int</span> hp, <span class="type">int</span> mp) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;hp = hp;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mp = mp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SolidAttack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;This is SolidAttack&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> :<span class="keyword">public</span> Enemy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Boss</span>(<span class="type">int</span> hp, <span class="type">int</span> mp)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;hp = hp;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mp = mp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BossAttack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;This is BossAttack&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Solid <span class="title">solid</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">Boss <span class="title">boss</span><span class="params">(<span class="number">1000</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">	solid.<span class="built_in">SolidAttack</span>();</span><br><span class="line">	boss.<span class="built_in">BossAttack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实例化一个子类时，会先调用父类的构造函数，再调用子类的构造函数。</p>
<p>在销毁时，会先调用子类的析构函数，再调用父类的析构函数。</p>
<p><strong>多继承：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用如下语法进行多继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span>:<span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用多继承时，出现菱形继承会导致成员不明确。</span></span><br><span class="line"><span class="comment">//如：类A，与类B均继承自类Base，现有类C多继承类A与类B，则会导致成员不明确</span></span><br><span class="line"><span class="comment">//1.使用作用域可以访问不同父类的相同成员</span></span><br><span class="line"><span class="comment">//2.使用virtual关键字处理重复数据，如下：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AClass</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BClass</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CClass</span>:<span class="keyword">public</span> AClass,<span class="keyword">public</span> BClass&#123;&#125;;</span><br><span class="line"><span class="comment">//此时CClass中仅会继承1个data，不会再出现不明确。</span></span><br></pre></td></tr></table></figure>
<h4 id="112继承时子类与父类的同名成员"><a class="markdownIt-Anchor" href="#112继承时子类与父类的同名成员">#</a> (11.2) 继承时子类与父类的同名成员</h4>
<p>当子类中出现与父类中同名的成员时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于同名成员：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子类成员属性=&quot;</span> &lt;&lt; s.element &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;父类成员属性=&quot;</span> &lt;&lt; s.Father::element &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子类成员函数&quot;</span> &lt;&lt; s.<span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;父类成员函数&quot;</span> &lt;&lt; s.Father::<span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//如果子类中出现父类同名的成员函数，子类的同名成员函数会隐藏父类所有的同名成员函数(包括重载)</span></span><br><span class="line">    <span class="comment">//如果想调用父类中被隐藏的同名成员函数，需要加作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态成员，同上。</p>
<h3 id="12多态"><a class="markdownIt-Anchor" href="#12多态">#</a> (12) 多态</h3>
<p>1. 多态分为两类：</p>
<ul>
<li>静态多态：函数重载和运算符重载属于静态多态，复用函数名。</li>
<li>动态多态：派生类和虚函数实现运行时多态。</li>
</ul>
<p>2. 静态多态和动态多态的区别：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//添加virtual关键字，使函数地址晚绑定</span></span><br><span class="line">    <span class="comment">//从而实现speak函数发出小猫在说话</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">(Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">speak</span>(cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多态满足条件：</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件：</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型、函数名、参数列表完全一致称为重写</p>
<h4 id="121纯虚函数与抽象类"><a class="markdownIt-Anchor" href="#121纯虚函数与抽象类">#</a> (12.1) 纯虚函数与抽象类</h4>
<p>纯虚函数：使用 virtual 关键字修饰，并且无实现的类成员函数。</p>
<p>语法：virtual void func () = 0;</p>
<p>抽象类：只要其中有一个纯虚函数，则这个类称为抽象类。</p>
<p>1. 抽象类无法实例化。</p>
<p>2. 抽象类的子类必须重写纯虚函数，否则该子类也为抽象类。</p>
<h4 id="122虚析构与纯虚析构"><a class="markdownIt-Anchor" href="#122虚析构与纯虚析构">#</a> (12.2) 虚析构与纯虚析构</h4>
<p>当使用父类指针指向子类，若子类中存有堆区数据，则结束时，仅调用父类的析构函数可能会无法释放子类的堆区数据，从而导致内存泄漏。</p>
<p>解决方法：将父类的析构函数改为虚析构函数。</p>
<p>纯虚析构：纯虚析构需要声明，也需要实现。</p>
<h3 id="13案例computer类"><a class="markdownIt-Anchor" href="#13案例computer类">#</a> (13) 案例：Computer 类</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelGPU</span> :<span class="keyword">public</span> GPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMDCPU</span> :<span class="keyword">public</span> CPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMDGPU</span> :<span class="keyword">public</span> GPU &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZQMemory</span> :<span class="keyword">public</span> Memory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGMemory</span> :<span class="keyword">public</span> Memory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU* cpu, Memory* memory, GPU* gpu);</span><br><span class="line">	~<span class="built_in">Computer</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	CPU* m_cpu;</span><br><span class="line">	Memory* m_memory;</span><br><span class="line">	GPU* m_gpu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Computer.h&quot;</span></span></span><br><span class="line">Computer::<span class="built_in">Computer</span>(CPU* cpu, Memory* memory, GPU* gpu) &#123;</span><br><span class="line">	m_cpu = cpu;</span><br><span class="line">	m_memory = memory;</span><br><span class="line">	m_gpu = gpu;</span><br><span class="line">&#125;</span><br><span class="line">Computer::~<span class="built_in">Computer</span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">delete</span> m_cpu;</span><br><span class="line">		m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m_memory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">delete</span> m_memory;</span><br><span class="line">		m_memory = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m_gpu != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">delete</span> m_gpu;</span><br><span class="line">		m_gpu = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Computer::work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line">	m_memory-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	m_gpu-&gt;<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntelCPU::calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;IntelCPU正在计算&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntelGPU::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;IntelGPU正在显示&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMDCPU::calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;AMDCPU正在计算&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMDGPU::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;AMDGPU正在显示&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZQMemory::storage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;芝奇内存条正在存储&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MGMemory::storage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;镁光内存条正在存储&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Computer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Computer <span class="title">computer</span><span class="params">(<span class="keyword">new</span> IntelCPU, <span class="keyword">new</span> ZQMemory, <span class="keyword">new</span> AMDGPU)</span></span>;</span><br><span class="line">	computer.<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10模板"><a class="markdownIt-Anchor" href="#10模板">#</a> <mark>10. 模板</mark></h2>
<p>C++ 另一种编程思想称为<mark>泛型编程</mark>，主要利用的技术就是模板</p>
<p>C++ 提供两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></p>
<h3 id="121调用规则"><a class="markdownIt-Anchor" href="#121调用规则">#</a> (12.1) 调用规则</h3>
<p>1. 如果函数模板和普通函数都可以实现，优先调用普通函数。</p>
<p>2. 可以通过空模板参数列表来强制调用函数模板。</p>
<p>3. 函数模板也可以发生重载。</p>
<p>4. 如果函数模板可以产生更好的匹配，优先调用函数模板。</p>
<h3 id="122函数模板语法"><a class="markdownIt-Anchor" href="#122函数模板语法">#</a> (12.2) 函数模板语法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br><span class="line"><span class="comment">//template	声明创建模板</span></span><br><span class="line"><span class="comment">//typename	表面其后面的符号是一种数据类型，可以用class代替</span></span><br><span class="line"><span class="comment">//T	通用的数据类型，名称可以替换，通常为大写字母</span></span><br></pre></td></tr></table></figure>
<p>案例 1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapNum</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用方式：</span></span><br><span class="line">	<span class="comment">//1.自动类型推导</span></span><br><span class="line">	<span class="comment">//swapNum(a, b);</span></span><br><span class="line">	<span class="comment">//2.显示指定类型</span></span><br><span class="line">	<span class="built_in">swapNum</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\tb=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例 2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//选择排序模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(T arr[],<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="type">int</span> max = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[j]) &#123;</span><br><span class="line">				max = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">			T temp = arr[i];</span><br><span class="line">			arr[i] = arr[max];</span><br><span class="line">			arr[max] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//打印模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;<span class="comment">//字符数组排序</span></span><br><span class="line">	<span class="type">char</span> charArr[] = <span class="string">&quot;badcfe&quot;</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(charArr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">selectionSort</span>(charArr, len);</span><br><span class="line">	<span class="built_in">print</span>(charArr, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;<span class="comment">//整型数组排序</span></span><br><span class="line">	<span class="type">int</span> intArr[] = &#123;<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(intArr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">selectionSort</span>(intArr, len);</span><br><span class="line">	<span class="built_in">print</span>(intArr, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="123类模板语法"><a class="markdownIt-Anchor" href="#123类模板语法">#</a> (12.3) 类模板语法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="comment">//类模板的模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	NameType m_Name;</span><br><span class="line">	AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//类外实现成员函数</span></span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Person_Name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;\tPerson_Age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用类模板创建类时，不能自动类型推导</span></span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;Michael&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	p1.<span class="built_in">showPerson</span>();;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="124模板重载"><a class="markdownIt-Anchor" href="#124模板重载">#</a> (12.4) 模板重载</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Age</span>(age) &#123;&#125;;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//此模板不能用于Person类的比较，需要重载</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;<span class="comment">//重载格式</span></span><br><span class="line">	<span class="keyword">if</span> (p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Michael&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Michael&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">myCompare</span>(p1, p2))</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 == p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="125类模板与继承"><a class="markdownIt-Anchor" href="#125类模板与继承">#</a> (12.5) 类模板与继承</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若父类为一个类模板，则子类需要指出父类中的数据类型</span></span><br><span class="line"><span class="comment">//若要子类所需的类型也为灵活类型，则子类也需要是类模板</span></span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;<span class="comment">//模板基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	AgeType base_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; &#123;<span class="comment">//非模板派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C1</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;base_Age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;c1_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> c1_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;<span class="comment">//模板派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> :<span class="keyword">public</span> Base&lt;AgeType&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C2</span>(AgeType age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;base_Age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;c2_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	AgeType c2_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">C1 <span class="title">c1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">C2&lt;<span class="type">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C1:&quot;</span> &lt;&lt; <span class="string">&quot;\tbase_Age:&quot;</span> &lt;&lt; c1.base_Age &lt;&lt; <span class="string">&quot;\tc1_Age:&quot;</span> &lt;&lt; c1.c1_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C2:&quot;</span> &lt;&lt; <span class="string">&quot;\tbase_Age:&quot;</span> &lt;&lt; c2.base_Age &lt;&lt; <span class="string">&quot;\tc2_Age:&quot;</span> &lt;&lt; c2.c2_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="126类模板案例"><a class="markdownIt-Anchor" href="#126类模板案例">#</a> (12.6) 类模板案例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组类封装</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	DataType* pAddress;<span class="comment">//数组地址</span></span><br><span class="line">	<span class="type">int</span> m_Count;<span class="comment">//元素个数</span></span><br><span class="line">	<span class="type">int</span> m_Size;<span class="comment">//数组容量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">int</span> Size) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> DataType[<span class="keyword">this</span>-&gt;m_Size];</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">MyArray</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造，防止浅拷贝</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> MyArray&amp; arr) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Count = arr.m_Count;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">		<span class="comment">//深拷贝</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> DataType[arr.m_Size];</span><br><span class="line">		<span class="comment">//将arr中的数据都拷贝过来</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Count; i++) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//operator= 防止浅拷贝问题</span></span><br><span class="line">	MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; arr) &#123;</span><br><span class="line">		<span class="comment">//先判断原来堆区是否有数据，如果有，先释放</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Count = arr.m_Count;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">		<span class="comment">//深拷贝</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> DataType[arr.m_Size];</span><br><span class="line">		<span class="comment">//将arr中的数据都拷贝过来</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Count; i++) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_Back</span><span class="params">(<span class="type">const</span> DataType&amp; val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Count == <span class="keyword">this</span>-&gt;m_Size) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Array Full!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Count] = val;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Pop_Back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Count == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Count--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过下标方式访问数组中的元素，即重载[]运算符</span></span><br><span class="line">	DataType&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;</span><br><span class="line">		<span class="keyword">if</span> (index &gt; <span class="keyword">this</span>-&gt;m_Count - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回数组大小</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回数组内元素数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MyArray.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) :<span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_name &lt;&lt; <span class="string">&quot;\tage: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//MyArray测试代码</span></span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		arr[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; arr.<span class="built_in">getCount</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; arr.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	arr.<span class="built_in">Pop_Back</span>();</span><br><span class="line">	cout &lt;&lt; arr.<span class="built_in">getCount</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; arr.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	arr.<span class="built_in">Push_Back</span>(<span class="number">500</span>);</span><br><span class="line">	cout &lt;&lt; arr.<span class="built_in">getCount</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; arr.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自定义类型测试</span></span><br><span class="line">	<span class="function">MyArray&lt;Person&gt; <span class="title">pArr</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Michael&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	pArr[<span class="number">0</span>] = p1;</span><br><span class="line">	pArr[<span class="number">1</span>] = p2;</span><br><span class="line">	pArr[<span class="number">2</span>] = p3;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr.<span class="built_in">getCount</span>(); i++) &#123;</span><br><span class="line">		pArr[i].<span class="built_in">show</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11stl迭代器"><a class="markdownIt-Anchor" href="#11stl迭代器">#</a> <mark>11.STL 迭代器</mark></h2>
<h3 id="1迭代器"><a class="markdownIt-Anchor" href="#1迭代器">#</a> (1) 迭代器</h3>
<p>要访问顺序容器和关联容器中的元素，需要通过 “迭代器（iterator）” 进行。迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和指针类似。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器按照定义方式分成以下四种。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1) 正向迭代器，定义方法如下：</span></span><br><span class="line"><span class="comment">//容器类名::iterator  迭代器名;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2) 常量正向迭代器，定义方法如下：</span></span><br><span class="line"><span class="comment">//容器类名::const_iterator  迭代器名;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3) 反向迭代器，定义方法如下：</span></span><br><span class="line"><span class="comment">//容器类名::reverse_iterator  迭代器名;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4) 常量反向迭代器，定义方法如下：</span></span><br><span class="line"><span class="comment">//容器类名::const_reverse_iterator  迭代器名;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过迭代器可以读取它指向的元素，*迭代器名就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">迭代器都可以进行++操作。反向迭代器和正向迭代器的区别在于：</span></span><br><span class="line"><span class="comment">对正向迭代器进行++操作时，迭代器会指向容器中的后一个元素；</span></span><br><span class="line"><span class="comment">而对反向迭代器进行++操作时，迭代器会指向容器中的前一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="2vector容器"><a class="markdownIt-Anchor" href="#2vector容器">#</a> (2) Vector 容器</h3>
<p>C++ STL 中的 verctor 好比是 C 语言中的数组，但是 vector 又具有数组没有的一些高级功能。与数组相比，vector 就是一个可以不用再初始化就必须制定大小的边长数组，当然了，它还有许多高级功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;type&gt; vectorName;<span class="comment">//创建一个vector</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="built_in">push_back</span>(element);<span class="comment">//尾插</span></span><br><span class="line">    vector[i];<span class="comment">//访问第i个元素，注意，添加元素需要使用push方法。此形式只可用于读取与修改</span></span><br><span class="line">    <span class="built_in">begin</span>();<span class="comment">//返回头</span></span><br><span class="line">    <span class="built_in">end</span>();<span class="comment">//返回尾</span></span><br><span class="line">    <span class="built_in">size</span>();<span class="comment">//返回vector的元素数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">insert</span>();<span class="comment">//插入元素、四种重载：</span></span><br><span class="line">    <span class="comment">//1. vector.insert(vector.begin(), value);//在头部插入value</span></span><br><span class="line">    <span class="comment">//2. vector.insert(vector.end(), number, value);//在尾部插入number个value</span></span><br><span class="line">    <span class="comment">//3. vector.insert(vector.end(), vector2.begin(), vector2.end());//在vector尾部插入整个vector2</span></span><br><span class="line">    <span class="comment">//4. vector.insert(vector.end(), &#123; value1, value2&#125;);//在其尾部插入value1与value2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pop_back</span>();<span class="comment">//删除尾部元素</span></span><br><span class="line">    <span class="built_in">erase</span>(element);<span class="comment">//删除element元素，并将后续元素前移</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assign</span>();<span class="comment">//两种情况：1. assign(n,val)将vector中元素变为n个val  </span></span><br><span class="line">    <span class="comment">//2. vectorName.assign(vector.begin(),vector.end())将vector中的元素赋值给vectorName</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12文件读写"><a class="markdownIt-Anchor" href="#12文件读写">#</a> <mark>12. 文件读写</mark></h2>
<p>C++ 中对文件操作需要包含头文件 &lt;fstream&gt;</p>
<p>文件类型分为两种：</p>
<ul>
<li>** 文本文件 - ** 文件以文本的<mark> ASCII 码</mark>形式存储在计算机中。</li>
<li>** 二进制文件 - ** 文件以文本的<mark>二进制</mark>形式存储在计算机中，用户一般不能直接读懂它们。</li>
</ul>
<p>操作文件分为三大类：</p>
<p>1.ofstrean：写操作</p>
<p>2.ifstream：读操作</p>
<p>3.fstream：读写操作</p>
<h3 id="121文件打开方式"><a class="markdownIt-Anchor" href="#121文件打开方式">#</a> (12.1) 文件打开方式</h3>
<table>
<thead>
<tr>
<th style="text-align:center">打开方式</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ios::in</td>
<td style="text-align:center">为读文件而打开文件</td>
</tr>
<tr>
<td style="text-align:center">ios::out</td>
<td style="text-align:center">为写文件而打开文件</td>
</tr>
<tr>
<td style="text-align:center">ios::ate</td>
<td style="text-align:center">初始位置：文件尾</td>
</tr>
<tr>
<td style="text-align:center">ios::app</td>
<td style="text-align:center">追加方式写文件</td>
</tr>
<tr>
<td style="text-align:center">ios::trunc</td>
<td style="text-align:center">如果文件存在，先删除，再创建</td>
</tr>
<tr>
<td style="text-align:center">ios::binary</td>
<td style="text-align:center">二进制方式</td>
</tr>
</tbody>
<tbody>
<tr>
<td style="text-align:center">注：文件打开方式可以配合使用，利用 ==</td>
<td style="text-align:center">== 操作符。</td>
</tr>
</tbody>
<tbody>
<tr>
<td style="text-align:center">例如：用二进制方式写文件：==ios::binary</td>
<td style="text-align:center">ios::out==</td>
</tr>
</tbody>
</table>
<h3 id="122写文件"><a class="markdownIt-Anchor" href="#122写文件">#</a> (12.2) 写文件</h3>
<p>步骤如下：</p>
<p>1. 包含头文件</p>
<p>2. 创建流对象  // 如：ofstream ofs;</p>
<p>3. 打开文件  // 如：ofs.open (“filePath”,openStyle);</p>
<p>4. 写数据  // 如：ofs &lt;&lt;“写入数据”;</p>
<p>5. 关闭文件  // 如：ofs.close ();</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out);</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;测试文本1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;测试文本2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="123读文件"><a class="markdownIt-Anchor" href="#123读文件">#</a> (12.3) 读文件</h3>
<p>步骤如下：</p>
<p>1. 包含头文件</p>
<p>2. 创建流对象</p>
<p>3. 打开文件，并判断是否打开成功</p>
<p>4. 读数据</p>
<p>5. 关闭文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		<span class="comment">//is_open函数判断文件是否打开成功，若成功则返回true</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读数据方式1：</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf) &#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//读数据方式2：</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf, sizeof(buf))) &#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//读数据方式3：</span></span><br><span class="line">	string buf;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf)) &#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//读数据方式4(不推荐)：</span></span><br><span class="line">	<span class="comment">//char c;</span></span><br><span class="line">	<span class="comment">//while ((c = ifs.get()) != EOF)//EOF：end of file</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="124二进制形式读写文件"><a class="markdownIt-Anchor" href="#124二进制形式读写文件">#</a> (12.4) 二进制形式读写文件</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p = &#123; <span class="string">&quot;张三&quot;</span>, <span class="number">18</span> &#125;;</span><br><span class="line">	fstream fs;</span><br><span class="line">	<span class="comment">//二进制方式写文件</span></span><br><span class="line">	fs.<span class="built_in">open</span>(<span class="string">&quot;./Person.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line">	fs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	fs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="comment">//二进制方式读文件</span></span><br><span class="line">	fs.<span class="built_in">open</span>(<span class="string">&quot;./Person.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line">	<span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Person p2;</span><br><span class="line">	fs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p2, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名&quot;</span> &lt;&lt; p2.m_Name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="string">&quot;年龄&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class="line">	fs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三-案例"><a class="markdownIt-Anchor" href="#三-案例">#</a> 三、案例</h1>
<h2 id="1职工管理系统"><a class="markdownIt-Anchor" href="#1职工管理系统">#</a> 1. 职工管理系统</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">公司中职工分为三类：普通员工，经理，老板，显示信息时，需要显示职工编号、职工姓名、职工岗位、以及职责。</span></span><br><span class="line"><span class="comment">普通员工职责：完成经理下发的任务。</span></span><br><span class="line"><span class="comment">经理职责：完成老板下发的任务，并下发任务给员工。</span></span><br><span class="line"><span class="comment">老板职责：管理公司所有事务。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">管理系统要求实现如下功能：</span></span><br><span class="line"><span class="comment">退出管理程序：退出当前管理系统</span></span><br><span class="line"><span class="comment">增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号。</span></span><br><span class="line"><span class="comment">显示职工信息：显示公司内所有职工的信息</span></span><br><span class="line"><span class="comment">删除离职职工：按照编号删除指定的职工</span></span><br><span class="line"><span class="comment">修改职工信息：按照编号修改职工个人信息</span></span><br><span class="line"><span class="comment">查找职工信息：按照职工编号或姓名查找相关人员的信息</span></span><br><span class="line"><span class="comment">排序功能：按照职工编号进行排序</span></span><br><span class="line"><span class="comment">清空所有文档：清空文件中记录的所有职工信息(并拥有防误删功能)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;wokerManager.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	wokerManager wm;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		wm.<span class="built_in">start</span>();</span><br><span class="line">		<span class="type">char</span> key = wm.<span class="built_in">cinFunction</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">		<span class="keyword">case</span><span class="number">&#x27;0&#x27;</span>:</span><br><span class="line">			wm.<span class="built_in">end</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">			wm.<span class="built_in">addEmp</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">			wm.<span class="built_in">showInfo</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">			wm.<span class="built_in">deleteEmp</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">			wm.<span class="built_in">mod_Emp</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">			wm.<span class="built_in">find_Emp</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">			wm.<span class="built_in">sort_Emp</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">			wm.<span class="built_in">renameId</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">			wm.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wokerManager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Woker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Employee.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Boss.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILENAME <span class="string">&quot;empFile.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wokerManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">wokerManager</span>();</span><br><span class="line">	~<span class="built_in">wokerManager</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">cinFunction</span><span class="params">(<span class="type">int</span> mod)</span></span>;<span class="comment">//控制键入</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;<span class="comment">//开始函数，打印开始菜单</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">end</span><span class="params">()</span></span>;<span class="comment">//结束函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addEmp</span><span class="params">()</span></span>;<span class="comment">//添加职工</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;<span class="comment">//显示职工信息</span></span><br><span class="line">	<span class="function">Woker** <span class="title">loadFile</span><span class="params">()</span></span>;<span class="comment">//读取文件</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span></span>;<span class="comment">//保存文件</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getEmpNum</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deleteEmp</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">isExist</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">mod_Emp</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">find_Emp</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sort_Emp</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> mod)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">renameId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> empNum;</span><br><span class="line">	Woker** wokerArr;</span><br><span class="line">	<span class="type">bool</span> m_FileIsEmpty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wokerManager.CPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wokerManager.h&quot;</span></span></span><br><span class="line">wokerManager::<span class="built_in">wokerManager</span>() &#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(FILENAME, ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;empNum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;wokerArr = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">		ifs.<span class="built_in">close</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	ifs &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ifs.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;empNum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;wokerArr = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">		ifs.<span class="built_in">close</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>-&gt;empNum = <span class="built_in">getEmpNum</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;wokerArr = <span class="built_in">loadFile</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">false</span>;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line">wokerManager::~<span class="built_in">wokerManager</span>() &#123;</span><br><span class="line">	<span class="keyword">if</span> (wokerArr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;wokerArr;</span><br><span class="line">		<span class="keyword">this</span>-&gt;wokerArr = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wokerManager::getEmpNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(FILENAME, ios::in);</span><br><span class="line">	<span class="type">int</span> id, DeptId;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; DeptId) &#123;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;******************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*****欢迎使用职工管理系统!****&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********0.退出管理系统********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********1.增加职工信息********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********2.显示职工信息********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********3.删除离职职工********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********4.修改职工信息********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********5.查找职工信息********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********6.按照编号排序********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********7.重置职工编号********&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;********8.清空所有文档********&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您确定要退出吗?(Y/N)：&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		<span class="type">char</span> choice;</span><br><span class="line">		cin &gt;&gt; choice;</span><br><span class="line">		<span class="keyword">if</span> (choice == <span class="string">&#x27;Y&#x27;</span> || choice == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="string">&#x27;N&#x27;</span> || choice == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入错误，请重新输入：&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">wokerManager::cinFunction</span><span class="params">(<span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入您的选择：&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">char</span> key;</span><br><span class="line">		cin &gt;&gt; key;</span><br><span class="line">		<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">		<span class="keyword">case</span><span class="number">&#x27;0&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> (mod == <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span><span class="number">&#x27;1&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span><span class="number">&#x27;2&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> (mod == <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">return</span> key;</span><br><span class="line">		<span class="keyword">case</span><span class="number">&#x27;3&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span><span class="number">&#x27;4&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span><span class="number">&#x27;5&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span><span class="number">&#x27;6&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span><span class="number">&#x27;7&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span><span class="number">&#x27;8&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> (mod == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span> key;</span><br><span class="line">		&#125;</span><br><span class="line">		cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入错误，请重新输入：&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::addEmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入你要添加的职工数：&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="type">int</span> addNum = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; addNum;</span><br><span class="line">		cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span> (addNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> newSize = <span class="keyword">this</span>-&gt;empNum + addNum;</span><br><span class="line">			Woker** newSpace = <span class="keyword">new</span> Woker * [newSize];</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;wokerArr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; empNum; i++) &#123;</span><br><span class="line">					newSpace[i] = <span class="keyword">this</span>-&gt;wokerArr[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; addNum; i++) &#123;</span><br><span class="line">				<span class="type">int</span> id, DeptId;</span><br><span class="line">				string name;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个职工的编号：&quot;</span>;</span><br><span class="line">				cin &gt;&gt; id;</span><br><span class="line">				cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个职工的姓名：&quot;</span>;</span><br><span class="line">				cin &gt;&gt; name;</span><br><span class="line">				cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;请选择该职工的岗位\t&quot;</span></span><br><span class="line">					&lt;&lt; <span class="string">&quot;1.普通员工&quot;</span> &lt;&lt; <span class="string">&quot;2.经理&quot;</span> &lt;&lt; <span class="string">&quot;3.老板\t：&quot;</span>;</span><br><span class="line">				cin &gt;&gt; DeptId;</span><br><span class="line">				cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">				Woker* woker = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="keyword">switch</span> (DeptId) &#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">					woker = <span class="keyword">new</span> <span class="built_in">Employee</span>(id, name, DeptId);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">					woker = <span class="keyword">new</span> <span class="built_in">Manager</span>(id, name, DeptId);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">					woker = <span class="keyword">new</span> <span class="built_in">Boss</span>(id, name, DeptId);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				newSpace[empNum + i] = woker;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;wokerArr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;wokerArr;</span><br><span class="line">				<span class="keyword">this</span>-&gt;wokerArr = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>-&gt;wokerArr = newSpace;</span><br><span class="line">			<span class="keyword">this</span>-&gt;empNum += addNum;</span><br><span class="line">			<span class="built_in">save</span>();</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">false</span>;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;添加完成！&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入错误，请重新输入：&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (wokerArr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;暂无职工信息&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; empNum; i++) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;wokerArr[i]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Woker** <span class="title">wokerManager::loadFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(FILENAME, ios::in);</span><br><span class="line">	<span class="type">int</span> id, DeptId, index = <span class="number">0</span>;</span><br><span class="line">	string name;</span><br><span class="line">	Woker** newSpace = <span class="keyword">new</span> Woker * [<span class="keyword">this</span>-&gt;empNum];</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; DeptId) &#123;</span><br><span class="line">		Woker* woker = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">switch</span> (DeptId) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			woker = <span class="keyword">new</span> <span class="built_in">Employee</span>(id, name, DeptId);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			woker = <span class="keyword">new</span> <span class="built_in">Manager</span>(id, name, DeptId);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			woker = <span class="keyword">new</span> <span class="built_in">Boss</span>(id, name, DeptId);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		newSpace[index] = woker;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> newSpace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::save</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(FILENAME, ios::trunc);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; empNum; i++) &#123;</span><br><span class="line">		ofs &lt;&lt; <span class="keyword">this</span>-&gt;wokerArr[i]-&gt;m_Id &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">			&lt;&lt; <span class="keyword">this</span>-&gt;wokerArr[i]-&gt;m_Name &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">			&lt;&lt; <span class="keyword">this</span>-&gt;wokerArr[i]-&gt;m_DeptId &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::deleteEmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入要删除的职工的编号：&quot;</span>;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	cin &gt;&gt; index;</span><br><span class="line">	index = <span class="built_in">isExist</span>(index);</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;职工编号未找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; empNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		wokerArr[i] = wokerArr[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">save</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;empNum--;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;删除成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wokerManager::isExist</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;empNum; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;wokerArr[i]-&gt;m_Id == id) &#123;</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::mod_Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入要修改的职工的编号：&quot;</span>;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	cin &gt;&gt; index;</span><br><span class="line">	index = <span class="built_in">isExist</span>(index);</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;职工编号未找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;修改前信息&quot;</span> &lt;&lt; endl;</span><br><span class="line">	wokerArr[index]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">	<span class="type">int</span> id, DeptId;</span><br><span class="line">	string name;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入修改后职工的编号：&quot;</span>;</span><br><span class="line">	cin &gt;&gt; id;</span><br><span class="line">	cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入修改后职工的姓名：&quot;</span>;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line">	cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择修改后职工的岗位\t&quot;</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;1.普通员工&quot;</span> &lt;&lt; <span class="string">&quot;2.经理&quot;</span> &lt;&lt; <span class="string">&quot;3.老板\t：&quot;</span>;</span><br><span class="line">	cin &gt;&gt; DeptId;</span><br><span class="line">	cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	Woker* woker = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">switch</span> (DeptId) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		woker = <span class="keyword">new</span> <span class="built_in">Employee</span>(id, name, DeptId);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		woker = <span class="keyword">new</span> <span class="built_in">Manager</span>(id, name, DeptId);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		woker = <span class="keyword">new</span> <span class="built_in">Boss</span>(id, name, DeptId);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	wokerArr[index] = woker;</span><br><span class="line">	<span class="built_in">save</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;修改完成！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::find_Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择查找方式：1.按照编号、2.按照姓名：&quot;</span>;</span><br><span class="line">	<span class="type">char</span> choice = <span class="built_in">cinFunction</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入职工的编号：&quot;</span>;</span><br><span class="line">		<span class="type">int</span> index;</span><br><span class="line">		cin &gt;&gt; index;</span><br><span class="line">		index = <span class="built_in">isExist</span>(index);</span><br><span class="line">		<span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;职工编号未找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		wokerArr[index]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入职工的姓名：&quot;</span>;</span><br><span class="line">		string name;</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;empNum; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;wokerArr[i]-&gt;m_Name == name) &#123;</span><br><span class="line">				<span class="keyword">this</span>-&gt;wokerArr[i]-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;员工未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::sort_Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (wokerArr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;暂无职工信息&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入排序方式：1.升序、2.降序：&quot;</span>;</span><br><span class="line">	<span class="type">char</span> choice = <span class="built_in">cinFunction</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">		<span class="built_in">Sort</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">		<span class="built_in">Sort</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::Sort</span><span class="params">(<span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mod == <span class="number">1</span>) &#123;<span class="comment">//升序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span>-&gt;empNum; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="comment">//假设最大值的下标为0</span></span><br><span class="line">			<span class="type">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">				<span class="comment">//从1开始遍历至i，当有大于arr[maxIndex]的值时</span></span><br><span class="line">				<span class="comment">//将标记最大值的下标指向它</span></span><br><span class="line">				<span class="keyword">if</span> (wokerArr[j]-&gt;m_Id &gt; wokerArr[maxIndex]-&gt;m_Id) maxIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将最大值交换到找到的位置</span></span><br><span class="line">			Woker* temp = wokerArr[i - <span class="number">1</span>];<span class="comment">//使用i时减一防止越界</span></span><br><span class="line">			wokerArr[i - <span class="number">1</span>] = wokerArr[maxIndex];</span><br><span class="line">			wokerArr[maxIndex] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (mod == <span class="number">2</span>) &#123;<span class="comment">//降序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span>-&gt;empNum; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="comment">//假设最大值的下标为0</span></span><br><span class="line">			<span class="type">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">				<span class="comment">//从1开始遍历至i，当有大于arr[maxIndex]的值时</span></span><br><span class="line">				<span class="comment">//将标记最大值的下标指向它</span></span><br><span class="line">				<span class="keyword">if</span> (wokerArr[j]-&gt;m_Id &lt; wokerArr[maxIndex]-&gt;m_Id) maxIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将最大值交换到找到的位置</span></span><br><span class="line">			Woker* temp = wokerArr[i - <span class="number">1</span>];<span class="comment">//使用i时减一防止越界</span></span><br><span class="line">			wokerArr[i - <span class="number">1</span>] = wokerArr[maxIndex];</span><br><span class="line">			wokerArr[maxIndex] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">save</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::renameId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;wokerArr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;暂无职工信息&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; empNum; i++) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;wokerArr[i]-&gt;m_Id = i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">save</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;重置完成!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wokerManager::clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您确定要清空文件吗?(Y/N)：&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		<span class="type">char</span> choice;</span><br><span class="line">		cin &gt;&gt; choice;</span><br><span class="line">		<span class="keyword">if</span> (choice == <span class="string">&#x27;Y&#x27;</span> || choice == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">			empNum = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">save</span>();</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;清除成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="string">&#x27;N&#x27;</span> || choice == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入错误，请重新输入：&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Woker.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//显示员工信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//获取部门名称</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">getDeptName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m_Id;<span class="comment">//职工编号</span></span><br><span class="line">	string m_Name;<span class="comment">//职工姓名</span></span><br><span class="line">	<span class="type">int</span> m_DeptId;<span class="comment">//部门编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Employee.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Woker.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:<span class="keyword">public</span> Woker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Employee</span>(<span class="type">int</span> id,string name,<span class="type">int</span> DeptId);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;<span class="comment">//展示职工信息</span></span><br><span class="line">	<span class="function">string <span class="title">getDeptName</span><span class="params">()</span></span>;<span class="comment">//获取员工部门名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Employee.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Employee.h&quot;</span></span></span><br><span class="line">Employee::<span class="built_in">Employee</span>(<span class="type">int</span> id, string name, <span class="type">int</span> DeptId) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_DeptId = DeptId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Employee::showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\t职工姓名：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\t职工部门：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getDeptName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\t职工职责：完成经理下发的任务&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Employee::getDeptName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;员工&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Manager.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Woker.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>:<span class="keyword">public</span> Woker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Manager</span>(<span class="type">int</span> id, string name, <span class="type">int</span> DeptId);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Manager.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Manager.h&quot;</span></span></span><br><span class="line">Manager::<span class="built_in">Manager</span>(<span class="type">int</span> id, string name, <span class="type">int</span> DeptId) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_DeptId = DeptId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Manager::showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\t职工姓名：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\t职工部门：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getDeptName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\t职工职责：完成老板下发的任务，并下发任务给员工&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Manager::getDeptName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;老板&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Boss.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Woker.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span>:<span class="keyword">public</span> Woker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Boss</span>(<span class="type">int</span> id, string name, <span class="type">int</span> DeptId);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Boss.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Boss.h&quot;</span></span></span><br><span class="line">Boss::<span class="built_in">Boss</span>(<span class="type">int</span> id, string name, <span class="type">int</span> DeptId) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_DeptId = DeptId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Boss::showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;职工编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\t职工姓名：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\t职工部门：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getDeptName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot;\t职工职责：管理公司所有事务&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Boss::getDeptName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;老板&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础</title>
    <url>/2023/02/20/C-Foundation/</url>
    <content><![CDATA[<h1 id="变量类型"><a class="markdownIt-Anchor" href="#变量类型">#</a> 变量类型</h1>
<p>C 语言是 强数据类型语言</p>
<p>int	整型		如果输出一个整数，使用 % d   如果是 long  ，则用 % ld，long long 为 % lld</p>
<p>double	小数		如果输出一个小数，使用 % f  或者用 %.2f  ，其中数字 2 表明保留两位小数</p>
<p>char	字符		如果输出字符，则用 % c  	如果输出字符串，则用 % s</p>
<h1 id="常量"><a class="markdownIt-Anchor" href="#常量">#</a> 常量</h1>
<p>整数常量  前缀为 0x 或 0x 表示十六进制	0 表示八进制，不带前缀表示十进制</p>
<p>可加后缀 U 和 L	U 表示无符号整数（unsigned）	L 表示长整数（long）	后缀不区分大小写</p>
<p>写东西时可用 \ 换行，如</p>
<p>hello \</p>
<p>world      输出为 hello world</p>
<p>#define 预处理器	可用于定义常量	#define 常量名 常量值</p>
<p>如  #define PI 3.14// 定义常量 PI 常量值 3.14</p>
<p>用 define 定义的常量不可修改</p>
<p>也可以用 const 定义常量	用法：const 数值类型 常量名 = 常量值</p>
<p>例如：const double PI = 3.14；	const 定义常量同样不可以修改</p>
<p>#define 和 const 均写在主函数外</p>
<p>#define 可以不加；在预处理时起作用	const 须加；在编译，运行时起作用</p>
<p>#define 只是简单的替换，没有类型检查。简单的字符串替换会导致边界效应</p>
<p>例如：</p>
<p>#define A 1</p>
<p>#define B A+3</p>
<p>#define C A/B*3</p>
<p>//C = A/A + 3 * 3 = 1 + 3 * 3 = 10</p>
<p>#define 不可以调试	const 可以进行调试</p>
<p>const 不能重复定义，不可以定义两个一样的，#define 可以通过 undef 取消某个符号的定义</p>
<p>#define 可以配合 #ifdef// 如果定义过，则	#endif	#ifndef// 如果未定义过，则	使用</p>
<h1 id="断点调试"><a class="markdownIt-Anchor" href="#断点调试">#</a> 断点调试</h1>
<p>左键双击代码最左端，可在该行创建一个断点</p>
<p>f5 开始执行断点调试 / 从下一断点开始执行调试</p>
<p>f10 逐过程运行，f11 逐语句运行；</p>
<p>逐过程时，当遇到函数，则会当成一个语句直接跑过。</p>
<p>逐语句时，遇到函数则会进入函数逐语句调试。</p>
<p>shift+f5 结束断点调试。</p>
<p>shift+f11 跳出函数体</p>
<h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符">#</a> 运算符</h1>
<p>取模公式：	a % b == a - (a /b) * b</p>
<p>关系运算符的结果要么为真（用非 0 表示，默认为 1），要么为假（用 0 表示）</p>
<p>逻辑运算符结果用 0（假），或非 0（真，默认为 1）表示</p>
<p>int A = 1,B = 0;</p>
<p>&amp;&amp; 称为逻辑与运算符，如果两个操作数都非 0，则条件为真 (A &amp;&amp; B = 0)</p>
<p>|| 称为逻辑或运算符，如果两个操作数中有任意一个非 0，则条件为真（A || B = 1）</p>
<p>！称为逻辑非运算符，用来逆转操作数的逻辑状态，\</p>
<p>如果条件为真则逻辑非运算符使其为假。例如：!(A &amp;&amp;B = 1)</p>
<p>C += 3	即为	C = C + 3		-= /= %= 同理</p>
<p>条件表达式？表达式 1：表达式 2；</p>
<p>如果条件表达式为非 0（真），则运行表达式 1，如果为 0（假），则运行表达式 2.</p>
<p>逗号的运算符优先级最低，</p>
<p>所有的双目运算符中只有赋值运算符的结合方向是从右向左</p>
<p>单目运算和三目运算从右向左</p>
<p>运算符大概的顺序为：</p>
<p>算术运算符	&gt;	关系运算符	&gt;	逻辑运算符 (逻辑非！除外)	&gt;	赋值运算符	&gt;	逗号运算符</p>
<h1 id="scanf与sprintf函数"><a class="markdownIt-Anchor" href="#scanf与sprintf函数">#</a> scanf 与 sprintf 函数</h1>
<p>使用 scanf 函数接收字符串时，字符串名即代表其地址</p>
<p>如	scanf（&quot;% s&quot;，name）;</p>
<p>scanf (&quot;% d&quot;,&amp;age); 中，要将输入值存放到 age 变量指向的地址，因此需要加 &amp;</p>
<p>scanf (&quot;% lf&quot;,&amp;sal); 使用 scanf 函数接收 double 类型时，格式参数为 % lf</p>
<p>scanf (&quot;% c&quot;,&amp;x); 输入字符串时需注意，若上一行也为输入函数，则用户输入回车时</p>
<p>会被 scanf 函数将回车识别为一个字符，并存入 x 中</p>
<p>sprintf 函数用于拼接字符（字符串）</p>
<p>sprintf(temp,&quot;\nxxx %d %.2f xxxxx&quot;,a,b);</p>
<p>表示将信息拼接并存入 temp;</p>
<h1 id="c语言执行方式与转义符"><a class="markdownIt-Anchor" href="#c语言执行方式与转义符">#</a> C 语言执行方式与转义符</h1>
<p>C 语言没有对象</p>
<p>程序源文件.c 进行编译执行 cl.exe 程序</p>
<p>形成 obj 文件，与库文件进行链接后（即 link.exe）</p>
<p>形成可执行的 exe 程序。</p>
<p>\ 为转义符</p>
<p>\t 为缩进  \n 下一行  \r 为回车</p>
<p>\r 指  ABB\rB  会将 \r 后方内容从头开始替换显示，显示为 BBB</p>
<h1 id="二进制八进制与十六进制转换"><a class="markdownIt-Anchor" href="#二进制八进制与十六进制转换">#</a> 二进制，八进制与十六进制转换</h1>
<p>假设有二进制数  11010101	转换为八进制数</p>
<p>将其划分为 3 个一组，若不足，在前方补 0 ，如</p>
<p>011，010，101：三个一组转换为十进制数：</p>
<p>011 = 3	010 = 2	101 = 5</p>
<p>则 11010101 转换为八进制数就是 325</p>
<p>假设有二进制数 11010101	转换为十六进制数</p>
<p>将其划分为 4 个一组，若不足，在前方补 0 ，如</p>
<p>1101，0101 ：四个一组转换为十六进制数（A-F 分别代表 10-15）：</p>
<p>1101 = D	0101 = 5</p>
<p>则 11010101 转换为十六进制数就是 D5</p>
<p>11，100，101	转八进制为 345</p>
<p>11，1001，0110	转十六进制为 396</p>
<p>八进制与十六进制转换为二进制则相反</p>
<p>如将 0237 转为二进制，则将每一位转换为三个数为一组的二进制数</p>
<p>0 = 0	2 = 010	3 = 011	7 = 111</p>
<p>则 0237 = 1，011，111</p>
<p>如将 0x23B 转为二进制，则将每一位转换为四个数为一组的二进制数</p>
<p>2 = 0010	3 = 0011	B = 1011</p>
<p>则 0x23B = 10，0011，1011</p>
<p>01230	转二进制为 1，010，011，000</p>
<p>0xAB29	转二进制为 1010,1011,0010,1001</p>
<h1 id="分支语句"><a class="markdownIt-Anchor" href="#分支语句">#</a> 分支语句</h1>
<p>需注意，while 和 for 为循环语句</p>
<p>switch 与 if 并非循环语句</p>
<p>for （循环变量初始化（语句 1）; 循环条件（语句 2）；循环变量迭代（语句 3））{代码块}；</p>
<p>表示 执行语句 1，判断语句 2 是否为真，若为真，执行代码块，结束后执行语句 3，再从语句 2 开始循环</p>
<p>若语句 2 为假，则结束 for 循环</p>
<p>while （表达式）{代码块}；</p>
<p>判断表示式是否为真，为真则执行代码块，执行结束再次判断，若为真则再次执行。</p>
<p>直至表达式判断为假，则结束 while 循环。（中间可用 break 强行结束）</p>
<p>注意：while 循环容易形成死循环，如</p>
<p>while （0 == 0）{printf（“死循环”）}，则在 debug 条件下，会不停的输出死循环导致卡死</p>
<p>switch （表达式）{	// 该表达式是也给常量表达式，必须是一个整型（char、short、int、long 等）											// 或枚举类型</p>
<p>​	case 常量 1:	// 当表达式值等于常量 1 时，执行以下所有代码块（包括 default 语句块）</p>
<p>​	代码块 1；</p>
<p>​	case 常量 2:	// 若不等于常量 1，则判断是否等于常量 2，执行从代码块 2 开始的下列代码块</p>
<p>​	代码块 2；		// 代码块后可用 break 强行结束</p>
<p>​	case 常量 n:	//case 语句中必须是常量，不能是变量</p>
<p>​	代码块 n；	// 若常量 1 符合，且中间无 break，则会从代码 1 一直执行到 default 语句，称为穿透</p>
<p>​	default：	// 若表达式值与以上常量皆不相等，则执行 default 语句块</p>
<p>​	default 语句块；	//default 并非必要</p>
<p>}</p>
<p>if （表达式 1）{代码块 1}		// 若表达式为真，则执行代码块，分支结束</p>
<p>else if （表达式 2）{代码块 2}	// 若表达式 1 为假，则判断表达式 2 是否为真</p>
<p>// 若为真，执行代码块 2，分支结束。（else if 并非必要）</p>
<p>else {代码块 3}	// 若表达式 1，表达式 2 皆为假，则执行代码块 3，分支结束。（else 并非必要）</p>
<h1 id="浮点类型-字符类型与布尔类型"><a class="markdownIt-Anchor" href="#浮点类型-字符类型与布尔类型">#</a> 浮点类型 字符类型与布尔类型</h1>
<p>// 浮点类型</p>
<p>float 单精度  占用 4 字节  精度为 6 位小数  值范围 1.2e-38 到 3.4E+38<br>
double 双精度  占用 8 字节  精度为 15 位小数  值范围 2.3E-308 到 1.7E+308<br>
5.12e2 = 5.12* 10^2 = 512	5.12e-2 = 5.12 * 10^-2 = 0.0512<br>
 浮点数是近似值<br>
浮点型常量默认为 double 型，声明 float 型常量时，须在后面加 f 或 F<br>
 输出时，% f 默认保留 6 位小数，若写为 %15f，则保留为 15 为小数</p>
<p>// 字符类型</p>
<p>字符类型是 char	char 是 1 个字节，可以存放数字或者字母</p>
<p>多个字符称为字符串，C 语言中使用 char 数组表示</p>
<p>% c 表示以字符的形式输出	字符需用’’</p>
<p>//vs2010 编译器是 c89</p>
<p>// 要求变量的定义在执行语句之前</p>
<p>// 布尔类型	boolean</p>
<p>0 表示假，非 0 表示真</p>
<h1 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针">#</a> 函数指针</h1>
<p>int max(int a,int b){</p>
<pre><code>return a&gt;b ? a : b;
</code></pre>
<p>}</p>
<p>void main(){</p>
<pre><code>int (*pmax)(int,int)=max;
</code></pre>
<p>}// 函数指针名为 pmax</p>
<p>//int 表示该函数指针指向的函数返还的是 int 类型</p>
<p>//（int，int）表示该函数指针指向的函数形参是接收两个 int，也可写上形参名</p>
<p>maxVal = （*pmax）（x,y）；// 通过函数指针调用函数，调用方式 1</p>
<p>maxVal = pmax (x,y);	// 调用方式 2</p>
<h1 id="结构体与共用体"><a class="markdownIt-Anchor" href="#结构体与共用体">#</a> 结构体与共用体</h1>
<p>结构体 struct</p>
<p>创建一个结构体，里面包含三个成员（变量），猫的名字，猫的年龄，猫的颜色</p>
<p>struct Cat {// 结构体名 Cat，Cat 就是我们自己构造的一个数据类型</p>
<p>​	char * name;</p>
<p>​	int age;</p>
<p>​	char * color;</p>
<p>};</p>
<p>// 使用 Cat 结构体，创建变量：</p>
<p>struct Cat cat1;</p>
<p>// 给 cat1 的各个成员赋值。</p>
<p><span class="exturl" data-url="aHR0cDovL2NhdDEubmFtZQ==">cat1.name</span> = “小白”;</p>
<p>cat1.age = 3;</p>
<p>cat1.color = “白色”;</p>
<p>// 输出猫的信息</p>
<p>printf (&quot;\n 第一只猫 name=% s，age=% d，color=% s&quot;,<span class="exturl" data-url="aHR0cDovL2NhdDEubmFtZQ==">cat1.name</span>,cat1.age,cat1.color);</p>
<p>结构体使自定义的数据类型（构造数据类型），表示的是一种数据类型</p>
<p>结构体变量代表一个具体变量</p>
<p><strong>例 int num1；//int 是整型数据类型，num1 是 int 变量</strong></p>
<p><strong>如 struct Cat cat1；//Cat 是结构体数据类型，cat1 是一个 Cat 变量</strong></p>
<p><strong>结构体传递默认是值传递，而非地址传递</strong></p>
<p>共用体 union</p>
<p>union 共用体名 {</p>
<p>​	成员列标</p>
<p>};</p>
<p>结构体的各个成员会占用不同的内存，互相之间没有影响，而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员</p>
<h1 id="静态数据函数中局部变量注意点"><a class="markdownIt-Anchor" href="#静态数据函数中局部变量注意点">#</a> 静态数据，函数中局部变量注意点</h1>
<p>如 int *func (){</p>
<p>​	int n = 100;</p>
<p>​	return &amp;n;</p>
<p>}</p>
<p>void main(){</p>
<p>​	int * ptr = func();</p>
<p>​	int n = *p;</p>
<p>}</p>
<p>将函数中局部变量的地址赋予整型指针 ptr 后，取指针 ptr 所指向的值赋予整型变量 n</p>
<p>须注意，函数运行结束后，栈将会被销毁，但内存数据并不会被清 0</p>
<p>而是放弃对该块内存的使用权限，该块内存可能会被其他语句调用</p>
<p>从而导致该地址内存放数据的改变，以影响 n 的值。</p>
<p>因此若要用函数将其中局部变量返还于主函数，须用 static 修饰。</p>
<p>如 static int n = 100;// 在 func 函数中改写成这样</p>
<p>表示整型 n 是一个静态数据，将被存于静态数据区（类似于全局变量）。</p>
<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型">#</a> 数据类型</h1>
<p>C 语言中数据类型包括</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">基本类型</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	数值类型</span><br><span class="line"></span><br><span class="line">​	&#123;</span><br><span class="line"></span><br><span class="line">​		整型</span><br><span class="line"></span><br><span class="line">​		&#123;</span><br><span class="line"></span><br><span class="line">​			短整型	<span class="type">short</span></span><br><span class="line"></span><br><span class="line">​			整型	<span class="type">int</span></span><br><span class="line"></span><br><span class="line">​			长整型	<span class="type">long</span></span><br><span class="line"></span><br><span class="line">​		&#125;</span><br><span class="line"></span><br><span class="line">​		浮点型</span><br><span class="line"></span><br><span class="line">​		&#123;</span><br><span class="line"></span><br><span class="line">​			单精度型	<span class="type">float</span></span><br><span class="line"></span><br><span class="line">​			双精度型	<span class="type">double</span></span><br><span class="line"></span><br><span class="line">​		&#125;</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	字符类型	<span class="type">char</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">构造类型</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	数组</span><br><span class="line"></span><br><span class="line">​	结构体	<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">​	共用体	<span class="title">union</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">​	枚举类型	<span class="title">enum</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">指针类型</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">空类型	<span class="title">void</span></span></span><br></pre></td></tr></table></figure>
<h1 id="数据类型转换"><a class="markdownIt-Anchor" href="#数据类型转换">#</a> 数据类型转换</h1>
<p>精度从低到高顺序</p>
<p>short	int	unsigned int	long	unsigned long	float	double	long double</p>
<p>C 程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型</p>
<p>强制类型转换符（）  格式：	（类型名）表达式</p>
<p>例：	（若浮点型强行转换为整型，则会将小数点后部分直接截断）</p>
<p>#include&lt;stdio.h&gt;</p>
<p>void main()</p>
<p>{</p>
<p>​	double d1 = 1.234;</p>
<p>​	int num = (int)d1;</p>
<p>}</p>
<p>// 这种强制类型转换，并不会使操作数（d1）发生类型改变</p>
<p>// 强制转换符只针对最近的操作数有效，若希望针对更多的表达式转换，须使用小括号</p>
<h1 id="位运算原码反码与补码"><a class="markdownIt-Anchor" href="#位运算原码反码与补码">#</a> 位运算，原码，反码与补码</h1>
<p>对于有符号的数而言：</p>
<p>1) 二进制的最高位是符号位，0 表示正数，1 表示负数</p>
<p>2) 正数的原码反码补码都一样（三码合一）</p>
<p>3) 负数的反码 = 它的原码符号位不变，其他位取反（0 取 1，1 取 0）‘</p>
<p>4) 负数的补码 = 它的反码 + 1</p>
<p>5) 0 的反码补码都是 0</p>
<p>6) 计算机运算时，都是以补码的方式来运算的</p>
<p>位运算符：</p>
<p>&amp; 按位与运算符	两边皆为 1 时才为 1，否则为 0，如</p>
<p>0&amp;0=0	0&amp;1=0	1&amp;1=1</p>
<p>| 按位或运算符	两边皆为 0 时才为 0，否则为 1，如</p>
<p>0|0=0	0|1=1	1|1=1</p>
<p>^ 异或运算符	两边相同时为 0，否则为 1，如</p>
<dl>
<dt>0^0=0	0^1=1	1^1=0</dt>
<dd>取反运算符	即 1 取 0，0 取 1，如</dd>
</dl>
<p>~1=0	~0=1</p>
<p>&lt;&lt; 左移运算符	将一个运算对象的各二进制位全部左移若干位</p>
<p>(左边的二进制位舍弃，右边补 0)，如</p>
<p>&gt;&gt; 右移运算符 	将一个运算对象的各二进制位全部右移若干位</p>
<p>(右边移除位舍弃，正数左边补 0，负数左边补 1)，如</p>
<p>int a = 1&gt;&gt;2		// 1/2/2=0</p>
<p>int b = -1&gt;&gt;2		= -1（详见详解 1）</p>
<p>例一：若对 2 取反（~2=），2 的原码<br>
为 00000000	00000000	00000000	00000010	（也为 2 的补码）取反则<br>
为 11111111	11111111	11111111	11111101	此时为结果的补码<br>
因 11111111	11111111	11111111	11111101	首位为 1，所以其为负数<br>
又因负数的补码 = 它的反码 + 1，所以它的反码 = 它的补码 - 1	则其反码<br>
为 11111111	11111111	11111111	11111100	则其原码（3）</p>
<p>为 10000000	00000000	00000000	00000011	可知为 - 3</p>
<p>则～2 = -3</p>
<p>例二：2&amp;-3=</p>
<p>2 的补码	00000000	00000000	00000000	00000010</p>
<p>-3 的反码	11111111	11111111	11111111	11111100</p>
<p>-3 的补码	11111111	11111111	11111111	11111101</p>
<p>则 2&amp;-3 为	00000000	00000000	00000000	00000000	（此为补码）</p>
<p>其为正数（三码合一），所以其原码也表示 0</p>
<p>详解 1：</p>
<p>原码	10000000	00000000	00000000	00000001	(-1 的原码)</p>
<p>反码	11111111	11111111	11111111	11111110</p>
<p>补码	11111111	11111111	11111111	11111111</p>
<p>右移	11111111	11111111	11111111	11111111	(负数右移后左边补 1，获得结果补码)</p>
<p>反码	11111111	11111111	11111111	11111110</p>
<p>原码	10000000	00000000	00000000	00000001	(结果为 - 1)</p>
<h1 id="栈堆与全局静态变量及动态内存分配"><a class="markdownIt-Anchor" href="#栈堆与全局静态变量及动态内存分配">#</a> 栈，堆与全局，静态变量及动态内存分配</h1>
<p>头文件 stdlib.h 中声明了四个关于内存动态分配的函数</p>
<p><strong>函数原型 void * malloc (unsigned int size)</strong>	//malloc 即 memory allocation</p>
<p><strong>作用–在内存的动态存储区（堆区）中分配一个长度为 size 的连续空间</strong></p>
<p>形参 size 的类型为无符号整型，函数的返回值是所分配区域的第一个字节的地址</p>
<p>即此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</p>
<p>malloc（100）；开辟 100 字节的临时空间，返回值为其第一个字节的地址</p>
<p><strong>函数原型 void * calloc (unsigned n,unsigned size)</strong></p>
<p><strong>作用–在内存的动态存储区中分配 n 个长度为 size 的连续空间，该空间一般比较大，足以保存一个数组</strong></p>
<p>用 calloc 函数可以为一维数组开辟动态存储空间，n 为数组元素个数，每个元素长度为 size</p>
<p>函数返回指向所分配域的起始位置的指针，分配不成功，返回 NULL。</p>
<p>p = calloc（50，4）；// 开辟一个 50*4 个字节的临时空间，把起始地址分配给指针变量 p</p>
<p>*<em> 函数原型 void free (void <em>p)</em></em></p>
<p><strong>作用–释放变量 p 所指向的动态空间，使这部分空间能重新被其他变量使用。</strong></p>
<p>free（p）；// 释放 p 所指向的已分配的动态空间</p>
<p>*<em> 函数原型 void * realloc (void <em>p,unsigned int size)</em></em></p>
<p><strong>作用–重新分配 malloc 或 calloc 函数获得的动态空间大小，将 p 指向的动态空间大小改变为 size，p 的值不变，分配失败返回 NULL。</strong></p>
<p>realloc（p，50）；// 将 p 所指向的已分配的动态空间改为 50 字节</p>
<p><strong>void * p 表示 p 中仅存放一个地址，该地址不指向任何数据</strong></p>
<p>仅在需要时分配内存，只要使用完堆上的内存块，就需要及时释放，否则可能出现<strong>内存泄漏</strong></p>
<p>尽量避免分配大量小的内存块。</p>
<h1 id="指针"><a class="markdownIt-Anchor" href="#指针">#</a> 指针</h1>
<p>#include&lt;stdio.h&gt;</p>
<p>int* ptr = &amp;num</p>
<p>int*  表示类型为指针类型</p>
<p>名称为 ptr，指向了一个 int 类型的变量的地址</p>
<p>输出地址时使用的时 % p</p>
<p>printf (“xxx 的地址为 % p”,&amp;xxx);</p>
<p>指针变量自身也有地址 &amp; ptr	指针变量存放的地址 ptr	指针变量存放的地址中存放的值 * ptr</p>
<p>基本类型都有对应的指针类型，int 对应 int*	float 对应 float*</p>
<p>int *ptr = arr []; 时</p>
<p>ptr 是一个指针类型，指向数组 arr [] 的首地址</p>
<p>*ptr 中 * 表示取值，printf 时，ptr 打印出 arr [] 首地址，*ptr 打印出 arr [0]</p>
<p>对 ptr 使用自增时，即 ptr++, 表示 ptr 自增一个 int 的字节数</p>
<p>即 ptr++ 等价于 ptr = ptr + 4.(但写出来的时候写成 + 1，表示增加 1 个 int 的字节数)(–同理)</p>
<p>指针数组</p>
<p>要让数组的元素指向某数据类型的地址（指针），可以使用指针数组</p>
<p>如 int *ptr [3]; 则定义一个指针数组</p>
<p>ptr 指向指针数组的首地址。</p>
<p>字符串的首地址即代表字符串内容</p>
<p>*pStr = &quot;abc&quot; 时，若要打印字符串，只需 pStr，并不需要 * pStr</p>
<p>可用 int **ptr 创建一个二级指针，二级指针内存放的内容是地址，该地址指向一个指针类型，指向的指针为一级指针，一级指针内存放的也为地址，该地址指向一个值。（int 表示该指针类型是 int 类型）</p>
<p>向上类推，有三级指针，，，多级指针。</p>
<h1 id="字符串与数相互转换"><a class="markdownIt-Anchor" href="#字符串与数相互转换">#</a> 字符串与数相互转换</h1>
<p>sprintf 函数存于 stdio.h 头文件下，可将结果存放到字符串中</p>
<p>sprintf(str1,&quot;%d%d&quot;,a,b);</p>
<p>sprintf(str2,&quot;%.2f&quot;,d);</p>
<p>sprintf (str3,&quot;%8.2f&quot;,d);//%8.2f 含义是格式化后，共有 8 位，小数点后占用 2 位，不够用空格占位，小数点也算位置。</p>
<p>int num1 = atoi (str);	//atoi (str) 将 str 转成整数</p>
<p>short s1 = atoi(str4);</p>
<p>double d = atof (str2);	//atof (str2) 将 str2 转成小数</p>
<p>char c = str3 [0];	//str3 [0] 表示获取到 str3 这个字符串（数组）的第一个 [0] 元素</p>
<h1 id="字符数组与字符指针"><a class="markdownIt-Anchor" href="#字符数组与字符指针">#</a> 字符数组与字符指针</h1>
<p>C 语言中并不存在字符串类型，字符串作为数组存在</p>
<p>每一个字符作为一个单独的元素</p>
<p>字符数组名是一个常量，不可改变</p>
<p>如	char str [10];</p>
<p>str = &quot;hello&quot; 是错误写法</p>
<p>char str [10]；时会在内存中创建一段空间用来存储或空或乱码</p>
<p>str = &quot;hello&quot; 会修改 str 指向的地址，从指向或空或乱码的地址改为指向字符串 &quot;hello&quot; 的地址</p>
<p>因为字符数组名是常量，所以会错误</p>
<p>char* a = “yes”;</p>
<p>a = “hello”，建立一个指针，此指针存储的地址指向一个 char 类型，该地址中存储为 &quot;yes&quot; 字符数组</p>
<p>随后改变 a 指针内存放的地址，新地址指向另一个字符数组</p>
<h1 id="写入与读取文件的函数"><a class="markdownIt-Anchor" href="#写入与读取文件的函数">#</a> 写入与读取文件的函数</h1>
<p>int fputc(int c,FILE * fp);</p>
<p>函数 fputc () 把参数 c 的字符写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生失误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中；</p>
<p>int fputs(const char *s,FILE *fp);</p>
<p>说明：函数 fputs () 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果错误，则会返回 EOF。您也可以使用 int fprint (FILE *fp,const char * format,…) 函数来写把一个字符串写入到文件中。</p>
<p>int fgetc(FILE * fp);</p>
<p>fgetc () 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF</p>
<p>char * fgets(char * buf,int n,FILE * fp);</p>
<p>1）说明：函数 fgets（）从 fp 所指向的输入流中读取 n-1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。</p>
<p>如果这个函数在读取最后一个字符之前就遇到一个换行符’\n’或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。</p>
<p>2）也可以使用 int fscanf (FILE * fp,const char * format,…) 函数来从文件中读取字符串，但是在遇到第一个空格字符时，它会停止读取。</p>
<h1 id="c语言打开与关闭文件"><a class="markdownIt-Anchor" href="#c语言打开与关闭文件">#</a> C 语言打开与关闭文件</h1>
<p>使用 stdio.h 头文件下的函数</p>
<p>fopen（）来创建一个新的文件或者打开一个已有的文件</p>
<p>这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息</p>
<p>原型：FILE *fopen（const char * filename,const char * mode）</p>
<p>1) filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个</p>
<p>r	打开一个已有的文本文件，允许<strong>读取</strong>文件</p>
<p>w	打开一个文本文件，允许<strong>写入</strong>文件。<strong>如果文件不存在，则会创建一个新的文件</strong>。在这里，您的程序会从文件的开头写入内容，<strong>如果文件存在，则会被截断为零长度，重新写入</strong>。</p>
<p>a	打开一个文本文件，以<strong>追加模式写入</strong>文件，<strong>如果文件不存在，则会创建一个文件</strong>。在这里，您的程序<strong>会在已有的文件内容中追加内容</strong>。</p>
<p>r+	打开一个文本文件，允许<strong>读写</strong>文件。</p>
<p>w+	打开一个文本文件，允许<strong>读写</strong>文件。<strong>如果文件已存在，则文件会被截断为零长度，如果不存在，则会创建一个新文件</strong>。</p>
<p>a+	打开一个文本文件，允许<strong>读写</strong>文件。<strong>如果文件不存在，则会创建一个新文件，读取会从文件的开头开始，写入则只能是追加模式。</strong></p>
<p><strong>若要打开二进制文件 (图片，视频等) 须在后面加 b，如 rb，rb+</strong></p>
<p>关闭文件，使用 fclose () 函数</p>
<p>原型：int fclose (FILE * fp);</p>
<p>如果成功关闭文件，则函数会返回 0. 如果文件关闭错误，则返回 EOF，EOF 是定义在 stdio.h 中的一个常量</p>
<h1 id="stringtimemath头文件应用"><a class="markdownIt-Anchor" href="#stringtimemath头文件应用">#</a> string,time,math 头文件应用</h1>
<p>string.h</p>
<p>strlen (str); 可用于统计字符串的大小</p>
<p>strcpy(char1,char2);</p>
<p>可将 char2 拷贝到 char1，将 char1 原内容覆盖</p>
<p>strcat(char1,char2);</p>
<p>可将 char2 连接在 char1 后面（接头霸王）</p>
<p>strcmp(char1,char2)</p>
<p>可将 char1 与 char2 中的字符串对比，若相同，则返回 0，若 char1&gt;char2，则返回值大于 0，反之小于 0</p>
<p>time.h</p>
<p>time_t curtime; time_t 为结构体，此语句为初始化 curtime</p>
<p>time (&amp;curtime);	获取当前时间，并插入 curtime 的地址中</p>
<p>math.h</p>
<p>double exp (double x)	返回 e 的 x 次幂的值</p>
<p>double log (double x)	返回 x 的自然对数（基数为 e 的对数）</p>
<p>double pow (double x,double y)	返回 x 的 y 次幂</p>
<p>double sqrt (double x)	返回 x 的平方根</p>
<p>double fabs (double x)	返回 x 的绝对值</p>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2023/02/19/DataStructureAndAlgorithms/</url>
    <content><![CDATA[<h1 id="数据结构与算法datastructureandalgorithms"><a class="markdownIt-Anchor" href="#数据结构与算法datastructureandalgorithms">#</a> 数据结构与算法 (DataStructureAndAlgorithms)</h1>
<h2 id="注该笔记使用c"><a class="markdownIt-Anchor" href="#注该笔记使用c">#</a> 注：该笔记使用 C++</h2>
<h2 id="testarrcreate"><a class="markdownIt-Anchor" href="#testarrcreate">#</a> TestArrCreate</h2>
<p>作用：生成一个 vector&lt;int&gt; arr; 用于测试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testArr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> arrLen;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">createArr</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getArrL</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testArr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">testArr::createArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	arrLen = <span class="built_in">rand</span>() % <span class="number">50</span>;<span class="comment">//长度为0-49</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">		arr.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">300</span>);<span class="comment">//数组中数的大小为0-299</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">testArr::getArrL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arrLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线性结构"><a class="markdownIt-Anchor" href="#线性结构">#</a> <mark>线性结构：</mark></h1>
<h2 id="一-栈stack"><a class="markdownIt-Anchor" href="#一-栈stack">#</a> 一、栈 (Stack)</h2>
<p><strong>特点:<mark> 先进后出 (FILO)</mark></strong>(First in Last out)</p>
<p>栈的结构类似于电梯，先进去的元素会在栈底，后进去的元素会在栈顶，后进的元素会先出，先进的元素会后出。</p>
<p>如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">|		|	(栈顶)	</span><br><span class="line">|		|</span><br><span class="line">|		|</span><br><span class="line">|		|</span><br><span class="line">---------	(栈底)</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line">|	(存入数据时)</span><br><span class="line">|</span><br><span class="line">V</span><br><span class="line"></span><br><span class="line">|		|	DATA1先入栈，在栈底</span><br><span class="line">|		|	DATA2后入栈，在栈顶</span><br><span class="line">| DATA2	|	DATA2会先出栈</span><br><span class="line">| DATA1	|	随后DATA1才能出栈</span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1c提供的栈"><a class="markdownIt-Anchor" href="#1c提供的栈">#</a> 1.C++ 提供的栈：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++提供的栈位于头文件&lt;stack&gt;中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;type&gt; stackName;<span class="comment">//创建一个stackName栈</span></span><br><span class="line">    stackName.<span class="built_in">empty</span>();<span class="comment">//如果栈为空，则返回true，否则返回false</span></span><br><span class="line">    stackName.<span class="built_in">size</span>();<span class="comment">//返回栈中元素的个数</span></span><br><span class="line">    stackName.<span class="built_in">top</span>();<span class="comment">//返回栈顶的元素，但不删除该元素</span></span><br><span class="line">    stackName.<span class="built_in">pop</span>();<span class="comment">//弹出栈顶元素，但不返回该元素</span></span><br><span class="line">    stackName.<span class="built_in">push</span>();<span class="comment">//将元素入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2使用c实现栈结构"><a class="markdownIt-Anchor" href="#2使用c实现栈结构">#</a> 2. 使用 C++ 实现栈结构：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过对栈结构的理解，可写出如下C++代码，来构建一个栈类</span></span><br><span class="line"><span class="comment">//此为头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> length;<span class="comment">//记录栈长</span></span><br><span class="line">	<span class="type">int</span> count;<span class="comment">//记录栈内元素数</span></span><br><span class="line">	<span class="type">int</span>* stack;<span class="comment">//栈头</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Stack</span>();<span class="comment">//构造</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">StackStatus</span><span class="params">()</span></span>;<span class="comment">//检查栈的状态，满、空、或正常</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">StackCount</span><span class="params">()</span></span>;<span class="comment">//返回栈的元素数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> val)</span></span>;<span class="comment">//入栈函数，将val写入栈中</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;<span class="comment">//出栈函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Stack::<span class="built_in">Stack</span>() &#123;<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;length = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;stack = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">this</span>-&gt;length * <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::StackCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回栈的存储元素数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::StackStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回栈的状态 0 为空，1为满，否则返回-1</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;count == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;count == <span class="keyword">this</span>-&gt;length) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stack::Push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果栈满，则扩栈</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">StackStatus</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;length *= <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span>* newStack = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">this</span>-&gt;length * <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;count; i++) &#123;</span><br><span class="line">			newStack[i] = <span class="keyword">this</span>-&gt;stack[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span>* oldStack = <span class="keyword">this</span>-&gt;stack;</span><br><span class="line">		<span class="keyword">this</span>-&gt;stack = newStack;</span><br><span class="line">		<span class="built_in">free</span>(oldStack);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将值存入栈，然后count++</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;stack[count] = val;</span><br><span class="line">	<span class="keyword">this</span>-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stack::Pop</span><span class="params">()</span> </span>&#123;<span class="comment">//出栈并将删除的数打印</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">StackStatus</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;count--;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;stack[count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3栈进制转换问题"><a class="markdownIt-Anchor" href="#3栈进制转换问题">#</a> 3. 栈：进制转换问题：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*使用栈将十进制数转换为二进制数*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> number = <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line">    Stack stack;</span><br><span class="line">    <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">        stack.<span class="built_in">Push</span>(number % <span class="number">2</span>);</span><br><span class="line">        number /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> stackLength = stack.<span class="built_in">StackCount</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stackLength; i++) &#123;</span><br><span class="line">        stack.<span class="built_in">Pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-队列queue"><a class="markdownIt-Anchor" href="#二-队列queue">#</a> 二、队列 (Queue)</h2>
<p><strong>特点:<mark> 先进先出 (FIFO)</mark></strong>(First in First out)</p>
<p>类似于排队。仅能从队尾进入，队首离开。</p>
<h3 id="1c提供的队列"><a class="markdownIt-Anchor" href="#1c提供的队列">#</a> 1.C++ 提供的队列：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++提供的队列位于头文件&lt;queue&gt;中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;type&gt; queueName;<span class="comment">//创建一个queueName队列</span></span><br><span class="line">    queueName.<span class="built_in">empty</span>();<span class="comment">//如果队列为空，返回true，否则返回false    </span></span><br><span class="line">	queueName.<span class="built_in">size</span>();<span class="comment">//返回队列中元素的个数</span></span><br><span class="line">	queueName.<span class="built_in">pop</span>();<span class="comment">//删除队列首元素但不返回其值</span></span><br><span class="line">	queueName.<span class="built_in">front</span>();<span class="comment">//返回队首元素的值，但不删除该元素</span></span><br><span class="line">	queueName.<span class="built_in">push</span>();<span class="comment">//在队尾压入新元素</span></span><br><span class="line">	queueName.<span class="built_in">back</span>();<span class="comment">//返回队列尾元素的值，但不删除该元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2队列热土豆问题"><a class="markdownIt-Anchor" href="#2队列热土豆问题">#</a> 2. 队列：热土豆问题：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用队列结构完成热土豆问题：</span></span><br><span class="line"><span class="comment">热土豆问题(约瑟夫问题、击鼓传花)：</span></span><br><span class="line"><span class="comment">从第1个人将热土豆向后传，选择一个数number，当热土豆传递到第number次时，持有热土豆的人离队，直到队列中只剩一人</span></span><br><span class="line"><span class="comment">解决思路：</span></span><br><span class="line"><span class="comment">1.热土豆不需要传递，只需将热土豆始终标记在队首</span></span><br><span class="line"><span class="comment">2.将队首移除加入队尾，视作一次传递</span></span><br><span class="line"><span class="comment">3.当传递到number次时，将队首永久移除</span></span><br><span class="line"><span class="comment">4.重复直至仅剩一人</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序实现：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    string seed[] = &#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;老六&quot;</span>, <span class="string">&quot;头七&quot;</span>, <span class="string">&quot;老八&quot;</span>, <span class="string">&quot;九哥&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(seed[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;<span class="comment">//假设number为5</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; number; i++) &#123;</span><br><span class="line">            string temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3队列打印任务问题"><a class="markdownIt-Anchor" href="#3队列打印任务问题">#</a> 3. 队列：打印任务问题：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    打印任务问题：</span></span><br><span class="line"><span class="comment">    一个实验室，在任意的一个小时内，大约有10名学生在场，</span></span><br><span class="line"><span class="comment">    这一个小时中，每个人会发起2次左右打印，每次1~20页。</span></span><br><span class="line"><span class="comment">    打印机的性能：</span></span><br><span class="line"><span class="comment">    以草稿模式打印：每分钟10页</span></span><br><span class="line"><span class="comment">    以正常模式打印：打印质量更高，每分钟5页</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如何设定打印机的模式，让所有人都不会等太久的前提下尽量提高打印质量?</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题思路：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    对象：打印任务、打印队列、打印机</span></span><br><span class="line"><span class="comment">    打印任务属性：提交时间、打印页数</span></span><br><span class="line"><span class="comment">    打印队列属性：具有FIFO性质的打印任务队列</span></span><br><span class="line"><span class="comment">    打印机属性：打印速度、工作状态(是否正忙)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    过程：</span></span><br><span class="line"><span class="comment">    1.生成和提交打印任务</span></span><br><span class="line"><span class="comment">    生成概率：每小时会有10个学生提交共计20个打印任务，约为每180秒提交一个打印任务</span></span><br><span class="line"><span class="comment">    则生成一份打印任务的概率为  (1/180) 每秒</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    2.打印页数：页数为1~20之间的概率相同</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    3.实施打印：当前正在进行的打印任务</span></span><br><span class="line"><span class="comment">    打印结束倒计时：新任务开始时进行倒计时，倒计时为0时打印完毕，执行下一打印任务</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    4.模拟时间：</span></span><br><span class="line"><span class="comment">    统一的时间框架：以统一最小单位(秒)均匀流逝的时间，设定结束时间</span></span><br><span class="line"><span class="comment">    同步所有过程：在一个时间单位里，对生成打印任务和实施打印两个过程各处理一次</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印机头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintProblem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">bool</span> free;<span class="comment">//打印机状态</span></span><br><span class="line">	<span class="type">float</span> speed;<span class="comment">//打印机打印速度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">PrintProblem</span>(<span class="type">int</span> type);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">(<span class="type">int</span> type)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//打印机源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PrintProblem.h&quot;</span></span></span><br><span class="line">PrintProblem::<span class="built_in">PrintProblem</span>(<span class="type">int</span> type) &#123;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">this</span>-&gt;speed = <span class="number">10.0</span> / <span class="number">60</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">this</span>-&gt;speed = <span class="number">5.0</span> / <span class="number">60</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;free = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintProblem::printType</span><span class="params">(<span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">this</span>-&gt;speed = <span class="number">10.0</span> / <span class="number">60</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">this</span>-&gt;speed = <span class="number">5.0</span> / <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;PrintProblem.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">printTask</span> &#123;<span class="comment">//打印任务结构体</span></span><br><span class="line">    <span class="type">int</span> startTime;<span class="comment">//开始时间</span></span><br><span class="line">    <span class="type">int</span> printTime;<span class="comment">//打印时间</span></span><br><span class="line">    <span class="type">int</span> printPage;<span class="comment">//打印页数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;<span class="comment">//模拟时间，单位秒</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    queue&lt;<span class="keyword">struct</span> printTask&gt; printQueue;<span class="comment">//该队列用于存储打印任务</span></span><br><span class="line">    <span class="function">PrintProblem <span class="title">printer</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//模式1为草稿模式，模式2为正常模式</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; waitTime;<span class="comment">//完成任务所需时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (flag &lt; <span class="number">3600</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rand</span>() % <span class="number">180</span> == <span class="number">0</span>) &#123;<span class="comment">//生成打印任务并加入打印队列</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">printTask</span> newTask;</span><br><span class="line">            newTask.printPage = <span class="built_in">rand</span>() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">            newTask.startTime = flag;</span><br><span class="line">            newTask.printTime = <span class="built_in">ceil</span>(newTask.printPage / printer.speed);            </span><br><span class="line">            printQueue.<span class="built_in">push</span>(newTask);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!printQueue.<span class="built_in">empty</span>() &amp;&amp; printer.free) &#123;<span class="comment">//开始打印任务</span></span><br><span class="line">            printer.free = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!printer.free) &#123;<span class="comment">//执行打印任务</span></span><br><span class="line">            printQueue.<span class="built_in">front</span>().printTime--;</span><br><span class="line">            <span class="keyword">if</span> (printQueue.<span class="built_in">front</span>().printTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                printer.free = <span class="literal">true</span>;</span><br><span class="line">                <span class="type">int</span> finishTime = flag;</span><br><span class="line">                waitTime.<span class="built_in">push</span>(finishTime - printQueue.<span class="built_in">front</span>().startTime);</span><br><span class="line">                printQueue.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> average = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">int</span> length = waitTime.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        average += waitTime.<span class="built_in">front</span>();</span><br><span class="line">        waitTime.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;平均等待时间&quot;</span> &lt;&lt; (average / length) &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="string">&quot;还有&quot;</span> &lt;&lt; printQueue.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个打印任务未完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-双端队列deque"><a class="markdownIt-Anchor" href="#三-双端队列deque">#</a> 三、双端队列 (Deque)</h2>
<h3 id="1c提供的双端队列"><a class="markdownIt-Anchor" href="#1c提供的双端队列">#</a> 1.C++ 提供的双端队列：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++提供的双端队列位于头文件&lt;deque&gt;中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    deque&lt;type&gt; dequeName;</span><br><span class="line">    <span class="comment">//下面为deque的方法</span></span><br><span class="line">    <span class="built_in">push_back</span>();<span class="comment">//在队列尾部添加元素，无返回值。</span></span><br><span class="line">	<span class="built_in">push_front</span>();<span class="comment">//在队列头部添加元素，无返回值；</span></span><br><span class="line">	<span class="built_in">pop_back</span>();<span class="comment">//删除队列尾部的元素，无返回值；</span></span><br><span class="line">	<span class="built_in">pop_front</span>();<span class="comment">//删除队列头部的元素，无返回值；</span></span><br><span class="line">	<span class="built_in">front</span>();<span class="comment">//获得队列头部元素。</span></span><br><span class="line">	<span class="built_in">back</span>();<span class="comment">//获得队列尾部元素。</span></span><br><span class="line">	<span class="built_in">size</span>();<span class="comment">//获得队列大小。</span></span><br><span class="line">	<span class="built_in">empty</span>();<span class="comment">//判断队列是否为空。队列空：返回true；不空：返回false。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2双端队列回文词判断"><a class="markdownIt-Anchor" href="#2双端队列回文词判断">#</a> 2. 双端队列：&quot;回文词&quot; 判断：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">“回文词”：指正读反读都一样的词，如：abccba</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*使用双端队列判断回文词*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;string&gt; dQ;</span><br><span class="line">    string huiWen[] = &#123; <span class="string">&quot;上&quot;</span>,<span class="string">&quot;海&quot;</span>,<span class="string">&quot;自&quot;</span>,<span class="string">&quot;来&quot;</span>,<span class="string">&quot;水&quot;</span>,<span class="string">&quot;来&quot;</span>,<span class="string">&quot;自&quot;</span> ,<span class="string">&quot;海&quot;</span>, <span class="string">&quot;上&quot;</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(huiWen) / <span class="built_in">sizeof</span>(huiWen[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dQ.<span class="built_in">push_front</span>(huiWen[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    len = dQ.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="type">bool</span> judge = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dQ.<span class="built_in">front</span>() == dQ.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            dQ.<span class="built_in">pop_front</span>();</span><br><span class="line">            dQ.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> judge = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (judge) cout &lt;&lt; <span class="string">&quot;该string为回文&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;该string不是回文&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-列表list"><a class="markdownIt-Anchor" href="#四-列表list">#</a> 四、列表 (List)</h2>
<h3 id="1c提供的列表"><a class="markdownIt-Anchor" href="#1c提供的列表">#</a> 1.C++ 提供的列表：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++提供的双端队列位于头文件&lt;deque&gt;中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    list&lt;type&gt; listName;<span class="comment">//创建一个列表</span></span><br><span class="line">    <span class="comment">//下面为列表的方法</span></span><br><span class="line">    <span class="built_in">begin</span>();<span class="comment">//返回表头</span></span><br><span class="line">    <span class="built_in">end</span>();<span class="comment">//返回表尾的后一个，实际为空，不能访问，常作为循环结束条件</span></span><br><span class="line">    <span class="built_in">push_front</span>();<span class="comment">//从表头插入元素</span></span><br><span class="line">    <span class="built_in">push_back</span>();<span class="comment">//从表尾插入元素</span></span><br><span class="line">    <span class="built_in">empty</span>();<span class="comment">//判断列表是否为空，若空则返回true，否则返回false</span></span><br><span class="line">    <span class="built_in">resize</span>();<span class="comment">//修改列表的长度，超出长度的元素将被删除</span></span><br><span class="line">    <span class="built_in">clear</span>();<span class="comment">//清空列表的所有元素</span></span><br><span class="line">    <span class="built_in">front</span>();<span class="comment">//返回表头元素</span></span><br><span class="line">    <span class="built_in">back</span>();<span class="comment">//返回表尾元素</span></span><br><span class="line">    <span class="built_in">pop_front</span>();<span class="comment">//删除表头元素</span></span><br><span class="line">    <span class="built_in">pop_back</span>();<span class="comment">//删除表尾元素</span></span><br><span class="line">    <span class="built_in">assign</span>();<span class="comment">//两种情况：1. assign(n,val)将列表中元素变为n个val  </span></span><br><span class="line">    <span class="comment">//2. listName.assign(list.begin(),list.end())将list中的元素赋值给listName</span></span><br><span class="line">    <span class="built_in">swap</span>();<span class="comment">//两种写法：1. list1.swap(list2) 2. swap(list1,list2) 作用：交换两个列表</span></span><br><span class="line">    <span class="built_in">reverse</span>();<span class="comment">//逆置列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge</span>();<span class="comment">//合并两个列表并排序(默认升序).</span></span><br><span class="line">    <span class="comment">//使用：list1.merge(list2,greater&lt;int&gt;());调用后将list2的元素合并到list1，并清空list2，同时对list1排序</span></span><br><span class="line">    <span class="comment">//排序方式默认为升序，其中greater&lt;int&gt;()可省略，排序方式可修改</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">insert</span>();<span class="comment">//间插，在指定位置插入一个或多个元素.</span></span><br><span class="line">    <span class="comment">//使用：list1.insert(index,number,val);在index位置插入number个val，其中number可省略，省略则为插入1个</span></span><br><span class="line">    <span class="comment">//特别：list1.insert(list1.begin(),list2.begin(),list2.end());在list1的头部插入list2的所有元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">erase</span>();<span class="comment">//删除一个元素，或一个区域的元素</span></span><br><span class="line">    <span class="comment">//1. list1.(index);将list1第index个元素删除</span></span><br><span class="line">    <span class="comment">//2. list1.(index1,index2);将list1种第index1到第index2之间的元素删除</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-散列表hash-table哈希表"><a class="markdownIt-Anchor" href="#五-散列表hash-table哈希表">#</a> 五、散列表 (Hash Table / 哈希表)</h2>
<p>创建一个存储空间，每个位置有对应的槽号，将数据存储后，只需要通过槽号进行读取。</p>
<p>则可以实现时间复杂度为 O (1) 的查找速度。</p>
<p>我们将数据项占据的比例称为散列表的 &quot;负载因子&quot;。例如：</p>
<p>某散列表大小为 11，存储项共 6 个，则其负载因子为 6/11</p>
<p><strong>冲突：指两项数据，通过散列函数计算后，得到相同的 Hash 值</strong></p>
<h3 id="1散列函数"><a class="markdownIt-Anchor" href="#1散列函数">#</a> 1. 散列函数</h3>
<p>(1) 求余散列函数：</p>
<p>假设散列表的总大小为 size，要存储的数据项为 item，则可以使用 h (item) = item % size</p>
<p>其中 h (item) 为 item 对应的存储槽号。若冲突，则将槽号向后顺延。</p>
<p>(2) 折叠散列函数：</p>
<p>将数据项按照位数分为若干段，再将几段数字相加，最后使用散列表大小求余，得到散列值。</p>
<p>(3) 平方取中散列函数：</p>
<p>先将数据项做平方运算，然后取平方数的中间两位。再对散列表大小求余。</p>
<h3 id="2md5与sha"><a class="markdownIt-Anchor" href="#2md5与sha">#</a> 2.MD5 与 SHA</h3>
<p>MD5 与 SHA 都是为了实现散列表槽位计算而出现的散列表函数。</p>
<p>将任意数据进行 MD5 或 SHA 计算后，会获得相应的散列值 (MD5 计算出的 Hash 值为 128 位，SHA0 计算出的 Hash 值为 160 位)</p>
<p>使用 MD5 或 SHA 计算出的 Hash 值几乎不存在冲突的可能。</p>
<h3 id="3区块链技术"><a class="markdownIt-Anchor" href="#3区块链技术">#</a> 3. 区块链技术</h3>
<p>区块链的发展得益于散列函数。</p>
<p><strong>区块链是大规模的分布式数据库。</strong></p>
<p>区块链的最本质特征是 &quot;去中心化&quot;。不存在任何控制中心、协调中心节点。所有的节点都是平等的，无法被控制。</p>
<p>区块链由一个个区块 (block) 组成，区块分为头 (head) 和体 (body)。</p>
<p>区块头记录了一些元数据和链接到前一个区块的信息：生成时间、前一个区块的散列值。</p>
<p>工作量证明 (Proof of Work):</p>
<p>由于区块链是大规模的分布式数据库，同步较慢，新区快的添加速度需要得到控制。</p>
<p>目前最大规模区块链 Bitcoin (比特币) 采用的速度是平均每 10 分钟生成一个区块。</p>
<h3 id="4处理冲突"><a class="markdownIt-Anchor" href="#4处理冲突">#</a> 4. 处理冲突</h3>
<p>(1) 开放地址</p>
<p>将冲突的数据项向后顺延，或者跳跃式顺延。</p>
<p>如 data1 和 data2 同样对应 0，则 data1 存于 0，data2 顺延存于 1。</p>
<p>但是这种顺延方式，若是冲突较多，则会导致冲突数据大量集中。</p>
<p>因此可以采取跳跃式顺延解决。</p>
<p>如 data1 存于 0，data2 存于 0+skip，skip 可以是任意不可以整除表大小的数。如果 skip 可以整除表，则会有部分槽永远不会被顺延。</p>
<p>(2) 数据链</p>
<p>将槽位的存储空间扩大。</p>
<p>如 data1 和 data2 同样对应 0，则使用数组等方式，将之一起存入 0 槽位。</p>
<p>查找时使用顺序查找的方式，从而获取数据项。这是介于 O (1) 和 O (n) 之间的选择。</p>
<h3 id="5c提供的map类"><a class="markdownIt-Anchor" href="#5c提供的map类">#</a> 5.C++ 提供的 map 类</h3>
<p>map 是 STL 的一个关联容器，它提供一对一的 hash。</p>
<p>​	第一个可以称为关键字 (key)，每个关键字只能在 map 中出现一次；</p>
<p>​	第二个可能称为该关键字的值 (value)；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++提供的map类位于头文件&lt;map&gt;中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;keyType, valueType&gt; mapName;<span class="comment">//创建一个map对象，通常keyType为int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来以创建学生map对象为例</span></span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">begin</span>();<span class="comment">//返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。</span></span><br><span class="line">    <span class="built_in">end</span>();<span class="comment">//返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。</span></span><br><span class="line">    <span class="built_in">rbegin</span>();<span class="comment">//返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。</span></span><br><span class="line">    <span class="built_in">rend</span>();<span class="comment">//返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cbegin</span>(); <span class="comment">//和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</span></span><br><span class="line">	<span class="built_in">cend</span>();   <span class="comment">//和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</span></span><br><span class="line">	<span class="built_in">crbegin</span>();<span class="comment">//和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</span></span><br><span class="line">	<span class="built_in">crend</span>();  <span class="comment">//和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">find</span>(key);<span class="comment">//在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">lower_bound</span>(key);<span class="comment">//返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。</span></span><br><span class="line">    <span class="built_in">upper_bound</span>(key);<span class="comment">//返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">equal_range</span>(key);</span><br><span class="line">    <span class="comment">//该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价。</span></span><br><span class="line">    <span class="comment">//pair.second 和 upper_bound() 方法的返回值等价。</span></span><br><span class="line">    <span class="comment">//也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">empty</span>();<span class="comment">//若容器为空，则返回 true；否则 false。</span></span><br><span class="line">    <span class="built_in">size</span>();<span class="comment">//返回当前 map 容器中存有键值对的个数。</span></span><br><span class="line">    <span class="built_in">max_size</span>();<span class="comment">//返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</span></span><br><span class="line">    <span class="keyword">operator</span>[];<span class="comment">//map容器重载了[]运算符，只要知道map容器中某个值对应的键，就可以向获取数组中元素那样，通过键直接获取对应的值。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">at</span>(key);<span class="comment">//找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">insert</span>(&#123;key,value&#125;);<span class="comment">//使用insert函数插入数据</span></span><br><span class="line">    <span class="built_in">erase</span>();<span class="comment">//删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。</span></span><br><span class="line">    <span class="built_in">swap</span>();<span class="comment">//交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</span></span><br><span class="line">    <span class="built_in">clear</span>();<span class="comment">//清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。</span></span><br><span class="line">    <span class="built_in">emplace</span>();<span class="comment">//在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</span></span><br><span class="line">    <span class="built_in">emplace_hint</span>();<span class="comment">//在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的。</span></span><br><span class="line">    <span class="comment">//不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">count</span>(key);<span class="comment">//在当前 map 容器中，查找键为 key 的键值对的个数并返回。</span></span><br><span class="line">    <span class="comment">//注意，由于 map 容器中各值对应的键是唯一的，因此该函数的返回值最大为 1。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法"><a class="markdownIt-Anchor" href="#算法">#</a> <mark>算法</mark></h1>
<h2 id="一-递归recursion"><a class="markdownIt-Anchor" href="#一-递归recursion">#</a> 一、递归 (Recursion)</h2>
<p>递归：指函数自我调用，分解问题，解决问题。</p>
<p>1. 存在一个大规模问题，可以被分解为小规模问题。</p>
<p>2. 小规模问题存在简单的解决方法。</p>
<p>3. 将小规模问题的结果汇总，得到大规模问题的解。</p>
<h3 id="1递归冒泡排序递归实现"><a class="markdownIt-Anchor" href="#1递归冒泡排序递归实现">#</a> (1) 递归：冒泡排序 (递归实现)</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照递归的解释，提供以下算法进行参考</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort::bubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">	arrLen--;</span><br><span class="line">	<span class="keyword">if</span> (arrLen &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="type">int</span> temp = arr[i];</span><br><span class="line">			arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">			arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, arrLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	Sort sort;</span><br><span class="line">	sort.<span class="built_in">bubbleSort</span>(arr, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-贪心策略greedy-method"><a class="markdownIt-Anchor" href="#二-贪心策略greedy-method">#</a> 二、贪心策略 (Greedy Method)</h2>
<p>优化问题：找到一个问题的最优解。</p>
<p>例如：在一个城市中，找到从 A 地到 B 地的最优路线。</p>
<h3 id="1贪心找零问题"><a class="markdownIt-Anchor" href="#1贪心找零问题">#</a> (1) 贪心：找零问题</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//贪心策略：每次都试图解决问题尽量大的一部分。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找零问题中，若要找回63，则优先使用25\*2，然后使用10\*1，最后使用1\*3。</span></span><br><span class="line"><span class="comment">//优先使用最大面值，试图解决尽量大的部分，是贪心策略的表现</span></span><br></pre></td></tr></table></figure>
<h2 id="三-动态规划dynamic-planning"><a class="markdownIt-Anchor" href="#三-动态规划dynamic-planning">#</a> 三、动态规划 (Dynamic Planning)</h2>
<h3 id="1动态规划背包问题"><a class="markdownIt-Anchor" href="#1动态规划背包问题">#</a> (1) 动态规划：背包问题</h3>
<p>现有 5 个物品，背包仅能负重 20 公斤，如何选取最高价值的物品？</p>
<table>
<thead>
<tr>
<th style="text-align:center">item</th>
<th style="text-align:center">weight</th>
<th style="text-align:center">value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
<p><strong>思路：</strong><br>
<strong>记 m (i,W) 为：前 i (1 &lt;= i &lt;= 5) 个宝物中，组合不超过 W (1 &lt;= W &lt;= 20) 重量，得到的最大价值</strong><br>
<strong> m (i,W) 应该取 m (i-1, W) 和 m (i-1, W-W<sub>i</sub>)+v<sub>i</sub> 其中价值更高的值</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		&#123;0											if i=0 or W=0	</span></span><br><span class="line"><span class="comment">m(i,W)=&#123;m(i-1,W)									if Wi &gt; W</span></span><br><span class="line"><span class="comment">    	&#123;max&#123;m(i - 1, W),Vi + m(i - 1, W - Wi)&#125;		otherwise</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>则可以绘制动态规划表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">m(i\W)</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<p><strong>由公式可知：m (5,5) = m (4,5) = max {m (3,5), m (3,0) + 8}</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//物品最多数目 + 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_I 6</span></span><br><span class="line"><span class="comment">//背包最大承重 + 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_W 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">object</span> &#123;<span class="comment">//物品结构体</span></span><br><span class="line">	<span class="type">int</span> w;<span class="comment">//物品的重量</span></span><br><span class="line">	<span class="type">int</span> v;<span class="comment">//物品的价值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;object&gt; tr;<span class="comment">//创建列表存储物品的重量和价值</span></span><br><span class="line">	<span class="type">int</span> wArr[<span class="number">5</span>] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	<span class="type">int</span> vArr[<span class="number">5</span>] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;<span class="comment">//使用一个for循环将物品属性存储</span></span><br><span class="line">		object temp;</span><br><span class="line">		temp.w = wArr[i];</span><br><span class="line">		temp.v = vArr[i];</span><br><span class="line">		tr.<span class="built_in">push_back</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建二维数组m，模拟二维表格m(i,w)</span></span><br><span class="line">	<span class="comment">//初始化二维表格m(i,w)，其中i表示前i个宝物，w表示重量上限</span></span><br><span class="line">	<span class="comment">//表示前i个物品中，最大重量w的组合，所得到的最大价值</span></span><br><span class="line">	<span class="comment">//当i=0或w上限为0，价值均为0</span></span><br><span class="line">	<span class="type">int</span> m[MAX_I][MAX_W];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, w = <span class="number">0</span>; w &lt; MAX_W; w++) &#123;</span><br><span class="line">		m[i][w] = <span class="number">0</span>;<span class="comment">//当i=0时，m=0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; MAX_I; i++) &#123;</span><br><span class="line">		m[i][w] = <span class="number">0</span>;<span class="comment">//当w=0时，m=0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐个填写二维表格</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_I; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>; w &lt; MAX_W; w++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (tr[i - <span class="number">1</span>].w &gt; w) <span class="comment">//如果装不下第i个物品，这里i-1是因为tr是0-4而非1-5</span></span><br><span class="line">				m[i][w] = m[i - <span class="number">1</span>][w];<span class="comment">//不装第i个物品</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//如果装的下，使用max取不装第i个物品，与装第i个物品，两种情况下的最大价值 </span></span><br><span class="line">				m[i][w] = <span class="built_in">max</span>(m[i - <span class="number">1</span>][w],m[i - <span class="number">1</span>][w - tr[i - <span class="number">1</span>].w] + tr[i - <span class="number">1</span>].v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//打印表格</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; MAX_I; i++) &#123;</span></span><br><span class="line"><span class="comment">		for (int w = 0; w &lt; MAX_W; w++) &#123;</span></span><br><span class="line"><span class="comment">			cout &lt;&lt; m[i][w] &lt;&lt; &quot;  &quot;;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    cout &lt;&lt; m[<span class="number">5</span>][<span class="number">20</span>] &lt;&lt; endl;<span class="comment">//仅输出结果</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-查找search"><a class="markdownIt-Anchor" href="#四-查找search">#</a> 四、查找 (Search)</h2>
<h3 id="1顺序查找sequential-search"><a class="markdownIt-Anchor" href="#1顺序查找sequential-search">#</a> (1) 顺序查找 (Sequential Search)</h3>
<p>从数据头，向后逐个比对。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Search.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search::sequentialSearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> item, <span class="type">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (pos &lt; arrLen) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[pos] == item) <span class="keyword">return</span> pos;<span class="comment">//若找到返回下标</span></span><br><span class="line">		pos++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//表示未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2二分查找binary-search"><a class="markdownIt-Anchor" href="#2二分查找binary-search">#</a> (2) 二分查找 (Binary Search)</h3>
<p>二分查找基于二分法，仅能用于有序表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(log n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Search.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search::binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> item, <span class="type">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = arrLen - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">//当左标记超过右标记时，结束循环</span></span><br><span class="line">		<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (arr[mid] == item) <span class="keyword">return</span> mid;<span class="comment">//查找到时，返回下标</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (item &lt; arr[mid])<span class="comment">//若目标小于中间项</span></span><br><span class="line">			right = mid - <span class="number">1</span>;<span class="comment">//改变右标记</span></span><br><span class="line">		<span class="keyword">else</span><span class="comment">//若目标大于中间项</span></span><br><span class="line">			left = mid + <span class="number">1</span>;<span class="comment">//改变左标记</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//表示未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-排序sort"><a class="markdownIt-Anchor" href="#五-排序sort">#</a> 五、排序 (Sort)</h2>
<h3 id="1冒泡排序bubble-sort"><a class="markdownIt-Anchor" href="#1冒泡排序bubble-sort">#</a> (1) 冒泡排序 (Bubble Sort)</h3>
<p>仅将相邻的两项进行排序。</p>
<p>当首次冒泡后，最大项会被置于最后 (升序)。则下一次只需对前 n-1 个数排序。</p>
<p>以此类推，直到 n=2。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比对与交换的时间复杂度O(n^2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort::bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//对n-1个数排序</span></span><br><span class="line">	<span class="comment">//每次循环操作次数-1，所以i--</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>冒泡算法改进:</mark></p>
<p>如果一次排序中，没有任何数的位置发生改变，则说明已经排序完成，可以直接返回</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该优化不改变时间复杂度</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort::bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//对n-1个数排序</span></span><br><span class="line">	<span class="comment">//每次循环操作次数-1，所以i--</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="type">bool</span> exchange = <span class="literal">false</span>;<span class="comment">//记录是否发生交换</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				exchange = <span class="literal">true</span>;<span class="comment">//发生交换</span></span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!exchange) <span class="keyword">return</span>;<span class="comment">//若未发生交换，直接返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2选择排序selection-sort"><a class="markdownIt-Anchor" href="#2选择排序selection-sort">#</a> (2) 选择排序 (Selection Sort)</h3>
<p>在冒泡排序的思想上，对交换进行优化。</p>
<p>仍然进行多次对比，但不交换，记录最大项所在位置，最后再进行交换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序的比对时间复杂度为O(n^2),交换时间复杂度为O(n)。相较于冒泡排序优化了交换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Sort&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort::selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="comment">//假设最大值的下标为0</span></span><br><span class="line">		<span class="type">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">			<span class="comment">//从1开始遍历至i，当有大于arr[maxIndex]的值时</span></span><br><span class="line">			<span class="comment">//将标记最大值的下标指向它</span></span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[maxIndex]) maxIndex = j;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将最大值交换到找到的位置</span></span><br><span class="line">		<span class="type">int</span> temp = arr[i - <span class="number">1</span>];<span class="comment">//使用i时减一防止越界</span></span><br><span class="line">		arr[i - <span class="number">1</span>] = arr[maxIndex];</span><br><span class="line">		arr[maxIndex] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3插入排序insertion-sort"><a class="markdownIt-Anchor" href="#3插入排序insertion-sort">#</a> (3) 插入排序 (Insertion Sort)</h3>
<p>插入排序维持一个已经排好序的子列表，其位置始终在列表的前部，然后逐步扩大这个子列表直到全表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序的时间复杂度为O(n^2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Sort&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort::insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> index;<span class="comment">//下标</span></span><br><span class="line">	<span class="type">int</span> currentValue;<span class="comment">//当前值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		currentValue = arr[i];<span class="comment">//令当前值=arr[i]</span></span><br><span class="line">		index = i;<span class="comment">//下标=i，因为左侧是排序好的表，所以从i开始遍历即可</span></span><br><span class="line">		<span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; arr[index - <span class="number">1</span>] &gt; currentValue)&#123;<span class="comment">//当下标大于0并且当前值的左值大于当前值时</span></span><br><span class="line">			arr[index] = arr[index - <span class="number">1</span>];<span class="comment">//将左值后移(即与当前值交换位置)</span></span><br><span class="line">			index--;<span class="comment">//下标左移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//退出循环时，下标index的位置，即当前值应插入的位置</span></span><br><span class="line">		arr[index] = currentValue;<span class="comment">//插入当前值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4谢尔排序shell-sort"><a class="markdownIt-Anchor" href="#4谢尔排序shell-sort">#</a> (4) 谢尔排序 (Shell Sort)</h3>
<p>假设将数组 {6,5,4,3,2,1,9,8,7} 进行排序 (升序)。</p>
<p 9,8,7="">则可以将其划分为三个子数组，为 {6,5,4}、{3,2,1}、</p>
<p 4,5,6,1,2,3,7,8,9="">然后分别对其进行 c 插入排序，变为</p>
<p>可以发现，虽然并未变成完全有序，但是相对于原数组，是更有序的。</p>
<p>假设现有 n 个数需要进行排序。可以将其划分为 n / 2 个子数组进行排序</p>
<p>对排序后的数组再划分为 n / 4 个子数组进行排序，以此类推，直到 n / … 为 1 时，即为插入排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//谢尔排序会减少许多&quot;无效&quot;对比，所以略优于插入排序</span></span><br><span class="line"><span class="comment">//时间复杂度大约介于O(n)和O(n^2)之间</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gapInsertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> gap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = start + gap; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;<span class="comment">//对子数组排序</span></span><br><span class="line">		<span class="type">int</span> currentValue = arr[i];<span class="comment">//接下来与插入排序相同</span></span><br><span class="line">		<span class="type">int</span> index = i;</span><br><span class="line">		<span class="keyword">while</span> (index &gt;= gap &amp;&amp; arr[index - gap] &gt; currentValue) &#123;</span><br><span class="line">			arr[index] = arr[index - gap];</span><br><span class="line">			index = index - gap;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[index] = currentValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort::shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> subCount = arr.<span class="built_in">size</span>() / <span class="number">2</span>;<span class="comment">//设定间隔来划分子数组</span></span><br><span class="line">	<span class="keyword">while</span> (subCount &gt; <span class="number">0</span>) &#123;<span class="comment">//间隔为0时退出循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; subCount; start++)</span><br><span class="line">			<span class="built_in">gapInsertionSort</span>(arr, start, subCount);<span class="comment">//该函数对子数组进行排序</span></span><br><span class="line">		subCount /= <span class="number">2</span>;<span class="comment">//缩小间隔</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5归并排序merge-sort"><a class="markdownIt-Anchor" href="#5归并排序merge-sort">#</a> (5) 归并排序 (Merge Sort)</h3>
<p>归并排序是一种递归算法</p>
<p>思路是将数据表持续分裂为两半，并对两半分别进行排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序的时间复杂度为O(nlog n)。其中分裂过程的时间复杂度为O(log n),归并过程的时间复杂度为O(n)。</span></span><br><span class="line"><span class="comment">//归并排序使用更多的空间。(空间换时间)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort::mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;<span class="comment">//当数据被分为1时，则不需要再分割，也就不需要进入以下代码</span></span><br><span class="line">		<span class="type">int</span> mid = arr.<span class="built_in">size</span>() / <span class="number">2</span>;<span class="comment">//取中间点</span></span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftHalf</span><span class="params">(arr.begin(), arr.begin() + mid)</span></span>;<span class="comment">//分为左半部分		</span></span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightHalf</span><span class="params">(arr.begin() + mid, arr.end())</span></span>;<span class="comment">//分为右半部分</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">mergeSort</span>(leftHalf);<span class="comment">//对左半部分进行merge排序</span></span><br><span class="line">		<span class="built_in">mergeSort</span>(rightHalf);<span class="comment">//对右半部分进行merge排序</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;<span class="comment">//其中i为left的下标，j为right的下标，k为arr的下标</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (i &lt; leftHalf.<span class="built_in">size</span>() &amp;&amp; j &lt; rightHalf.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="comment">//拉链式交错把左右半部从小归到大归并到结果vector</span></span><br><span class="line">			<span class="keyword">if</span> (leftHalf[i] &lt; rightHalf[j]) &#123;</span><br><span class="line">				arr[k] = leftHalf[i];</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				arr[k] = rightHalf[j];</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//归并左半部剩余的部分</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; leftHalf.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			arr[k] = leftHalf[i];</span><br><span class="line">			i++;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//归并右半部剩余的部分</span></span><br><span class="line">		<span class="keyword">while</span> (j &lt; rightHalf.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			arr[k] = rightHalf[j];</span><br><span class="line">			j++;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6快速排序quick-sort"><a class="markdownIt-Anchor" href="#6快速排序quick-sort">#</a> (6) 快速排序 (Quick Sort)</h3>
<p>找到数据表的中值，并将数据表分为两半，随后自我调用，直到数据表仅有 1 项数据。</p>
<p>寻找中值：</p>
<p>1. 定义左标与右标，假设第一个值为中值，将左标向右移动，遇到第一个大于中值的项时停止。</p>
<p>2. 将右标向左移动，遇到第一个小于中值的项时停止。</p>
<p>3. 将左标与右标指向的值交换。随后继续重复左标右移，右标左移的步骤。</p>
<p>4. 当左标超过右标时，此时右标指向的值即为中值需要交换的位置。则可将中值与右标指向的值交换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序的时间复杂度为O(nlog n)。</span></span><br><span class="line"><span class="comment">//当分裂时，总能分为左右相同的两块，则其中分裂部分的复杂度为O(log n),移动部分的时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">//当中值所在位置过于偏离中部，造成左右两块数量不平衡，会导致时间复杂度上升</span></span><br><span class="line"><span class="comment">//极端情况下，有一部分始终没有数据，则时间复杂度退化到O(n^2),考虑到递归调用，效率甚至低于冒泡排序</span></span><br><span class="line"><span class="comment">//快速排序相较于归并排序，不需要调用额外的空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMidI</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> first, <span class="type">int</span> last)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> midValue = arr[first];<span class="comment">//选定中值</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> leftMark = first + <span class="number">1</span>;<span class="comment">//左标</span></span><br><span class="line">	<span class="type">int</span> rightMark = last;<span class="comment">//右标</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">//当左标小于右标，且左标指向的值小于中值时，左标右移</span></span><br><span class="line">		<span class="keyword">while</span> (leftMark &lt;= rightMark &amp;&amp; arr[leftMark] &lt;= midValue) leftMark++;</span><br><span class="line">		<span class="comment">//当右标大于左标，且右标指向的值大于中值时，右标左移</span></span><br><span class="line">		<span class="keyword">while</span> (rightMark &gt;= leftMark &amp;&amp; arr[rightMark] &gt;= midValue) rightMark--;</span><br><span class="line">		<span class="keyword">if</span> (rightMark &lt; leftMark) <span class="keyword">break</span>;<span class="comment">//当左标大于右标，结束循环</span></span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//否则当左标和右标都停止时，交换左标与右标指向的值</span></span><br><span class="line">			<span class="type">int</span> temp = arr[leftMark];</span><br><span class="line">			arr[leftMark] = arr[rightMark];</span><br><span class="line">			arr[rightMark] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后将中值置于rightMark处</span></span><br><span class="line">	<span class="type">int</span> temp = arr[first];</span><br><span class="line">	arr[first] = arr[rightMark];</span><br><span class="line">	arr[rightMark] = temp;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回中值的下标</span></span><br><span class="line">	<span class="keyword">return</span> rightMark;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> first, <span class="type">int</span> last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first &lt; last) &#123;</span><br><span class="line">		<span class="type">int</span> midValue = <span class="built_in">getMidI</span>(arr,first,last);<span class="comment">//获取中值的下标</span></span><br><span class="line">		<span class="built_in">quickSortHelper</span>(arr, first, midValue - <span class="number">1</span>);<span class="comment">//从中值处分裂，处理中值左边的部分</span></span><br><span class="line">		<span class="built_in">quickSortHelper</span>(arr, midValue + <span class="number">1</span>, last);<span class="comment">//处理中值右边的部分</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort::quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">quickSortHelper</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
      <tags>
        <tag>DataStructureAndAlgorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2023/02/21/Linux-Foundation/</url>
    <content><![CDATA[<h1 id="部分可能会查询的常用指令"><a class="markdownIt-Anchor" href="#部分可能会查询的常用指令">#</a> 部分可能会查询的常用指令</h1>
<p><strong><mark>该笔记中给出 [选项] 仅为部分常用选项</mark></strong></p>
<h2 id="杂项"><a class="markdownIt-Anchor" href="#杂项">#</a> <mark>杂项</mark></h2>
<p><strong>init [0123456]	切换运行级别</strong></p>
<p><strong>man [命令或配置文件]	获取相关帮助信息</strong></p>
<p><strong>help [命令]	查看命令的帮助信息</strong></p>
<p><strong>clear	清屏</strong></p>
<p><strong>Ctrl+C	终止指令</strong></p>
<p><strong>ps [选项]	查看进程。a 显示当前终端所有进程，u 以用户的格式显示进程，x 显示后台进程运行的参数</strong></p>
<p><strong>top [选项]	动态查看进程。P 以 CPU 使用率排序 (默认)，M 以内存使用率排序，N 以 PID 排序，q 退出。</strong></p>
<p><strong>netstat [选项]	查看系统网络情况，an 按一定顺序排列输出，p 显示哪个进程在调用</strong></p>
<p><strong>chkconfig	给每个服务的各个运行级别设置自动启动 / 关闭</strong></p>
<p><strong>ls -i:PORT	检查 PORT 端口号占用</strong></p>
<h2 id="文件目录类"><a class="markdownIt-Anchor" href="#文件目录类">#</a> <mark>文件目录类</mark></h2>
<p><strong>pwd	显示当前工作目录的绝对路径</strong></p>
<p><strong>ls [选项] [目录或是文件]	-a 显示当前目录所有的文件和目录，-l 使之纵向排布</strong></p>
<p><strong>cd [参数]	表示 change directory，切换目录。~ 回到自己的家目录 … 回到上一级目录</strong></p>
<p><strong>mkdir [选项] 要创建的目录	创建目录，-p 创建多级目录</strong></p>
<p><strong>rmdir [选项] 要删除的空目录	删除一个空目录</strong></p>
<p><strong>rm -rf 要删除的目录	删除一个非空的目录。-r 为递归删除整个文件夹，-f 为强制删除不提示</strong></p>
<p><strong>touch 文件名称	创建一个空文件</strong></p>
<p><strong>cp [选项] 源文件 指定目录	拷贝源文件到指定目录。-r 递归复制整个文件夹</strong></p>
<p><strong>\cp 为强制拷贝，覆盖同名文件，并且不提示</strong></p>
<p><strong>mv 旧文件名 新文件名	给当前路径下的文件重命名</strong></p>
<p><strong>mv 文件名 指定目录	将当前目录下文件移动到指定目录</strong></p>
<p><strong>cat [选项] 文件名	以只读的方式打开文件。-n 为显示行号</strong></p>
<p><strong>more 文件名	以全屏方式按页显示文本内容，空格为下一页，回车为下一行，q 表示离开 Ctrl+F 向下滚动一屏，Ctrl+B 返回上一屏，= 输出当前的行号，:f 输出文件名和当前的行号</strong></p>
<p><strong>less	类似于 more，但仅加载需要显示的内容，查看大型文件更有效率。pageup 上一页，pagedown 下一页。/ 关键字 查找内容。n 向下查找，N 向上查找</strong></p>
<p><strong>&gt;	输出重定向	会将原来的文件的内容覆盖。如 ll &gt;a.txt 若无该文件，则会创建</strong></p>
<p><strong>&gt;&gt;	追加内容	会在原来的文件中追加内容</strong></p>
<p><strong>echo [选项] “内容”	输出内容，可以配合 &gt; 或 &gt;&gt; 将内容写入文件，$PATH 可以输出环境变量的路径</strong></p>
<p><strong>head [选项] 文件	查看文件的前 10 行 (默认)。-n 5 可以查看前 5 行</strong></p>
<p><strong>tail [选项] 文件	查看文件尾，-f 实时追踪该文档的所有更新</strong></p>
<p><strong>ln -s [源文件或目录] [软链接名称]	给源文件创建一个软链接 (快捷方式)</strong></p>
<p><strong>history [指令个数]	查看执行过的指令，! 行号，执行该行号指令</strong></p>
<h2 id="时间日期类"><a class="markdownIt-Anchor" href="#时间日期类">#</a> <mark>时间日期类</mark></h2>
<p><strong>date [“+ 选项”]	显示当前日期，% Y 显示当前年份，% m 月份，% d 日，% H 时，% M 分，% S 秒</strong></p>
<p><strong>date -s 字符串时间	设置时间，如 date -s &quot;2020-12-13 21:46:06&quot;</strong></p>
<p><strong>cal [年份]	显示当前日历或显示某一年日历</strong></p>
<h2 id="搜索查找类"><a class="markdownIt-Anchor" href="#搜索查找类">#</a> <mark>搜索查找类</mark></h2>
<p>*<em>find [搜索范围] [选项]	查找文件，-name 按文件名搜索，-user 按文件拥有者查找，-size [+ 或 - 大小] 按文件大小查找，-name <em>. 后缀 使用通配符查找</em></em></p>
<p><strong>locate [文件]	查找文件，使用该指令前须使用 updatedb 创建 locate 数据库</strong></p>
<p><strong>grep [选项] 查找内容 源文件	过滤查找，-n 显示匹配行及行号，-i 忽略字母大小写</strong></p>
<p><strong>|	管道符，表示将前一个命令的处理结果输出传递给后面的命令处理</strong></p>
<p><strong>操作案例：cat hello.txt | grep -n xxx</strong></p>
<h2 id="压缩和解压缩类"><a class="markdownIt-Anchor" href="#压缩和解压缩类">#</a> <mark>压缩和解压缩类</mark></h2>
<p><em><em>gzip 文件	将文件压缩为</em>.gz (压缩时会删除源文件)</em>*</p>
<p><strong>gunzip 文件.gz	将 gz 文件解压缩</strong></p>
<p><strong>zip [选项] 压缩文件名 源文件 / 目录	压缩为.zip，-r 递归压缩 (压缩时保留源文件)</strong></p>
<p><strong>unzip [选项] 指定目录 源文件.zip	将源文件.zip 解压到指定目录</strong></p>
<p><strong>tar [选项] *.tar.gz [源文件 1 源文件 2]	打包指令，将源文件压缩成 *.tar.gz 文件。-c 产生打包文件，-v 显示详细信息，-f 指定压缩后的文件名，-z 打包同时压缩，-x 解包.tar 文件。注：zcvf (打包) 或 zxvf (解包) 通常同时使用</strong></p>
<h1 id="1linux根目录下部分文件及其存储内容简单介绍"><a class="markdownIt-Anchor" href="#1linux根目录下部分文件及其存储内容简单介绍">#</a> 1.Linux 根目录下部分文件及其存储内容简单介绍</h1>
<p><strong><mark>加粗高亮为重要文件；高亮不加粗为操作难度较高的内核文件，不建议修改。</mark></strong></p>
<p><strong><mark>boot</mark></strong>	// 存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件</p>
<p><strong><mark>bin</mark></strong>	//Binary 的缩写，这个目录存放着最经常使用的命令</p>
<p><strong><mark>root</mark></strong>	// 该目录为系统管理员，也称作超级权限者的用户主目录</p>
<p><strong><mark>etc</mark></strong>	// 所有的系统管理所需要的配置文件和子目录</p>
<p><strong><mark>home</mark></strong>	// 存放普通用户的主目录，在 Linux 中每个用户都又一个自己的目录，一般该目录名以用户的账号命名</p>
<p><strong><mark>usr</mark></strong>	// 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 Windows 下的 program files 目录</p>
<p><strong><mark>media</mark></strong>	//Linux 系统会自动识别一些设备，例如 U 盘、光驱等，当识别后，Linux 会把识别的设备挂载到这个目录</p>
<p><strong><mark>mnt</mark></strong>	// 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载到 /mnt/ 上，然后进入该目录就可以查看里面的内容了。</p>
<p><strong><mark>usr/local</mark></strong>	// 这是另一个给主机额外安装软件所安装的目录。一般是通过编译码方式安装的程序。</p>
<p><strong><mark>var</mark></strong>	// 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</p>
<p><mark>proc</mark>	// 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息</p>
<p><mark>srv</mark>	//service 缩写，该目录存放一些服务启动之后需要提取的数据</p>
<p><mark>sys</mark>	<a href="//xn--linux2-h02mp66y.xn--6-0n6a4e06lm9bi7a15uijn25szv6aea">// 这是 linux2.6 内核的一个很大的变化</a>。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs。</p>
<p>dev	// 类似于 Windows 的设备管理器，把所有的硬件用文件的形式存储。</p>
<p>lib	// 系统开机所需要最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>
<p>lib64	// 库文件</p>
<p>opt	// 这是给主机额外安装软件所摆放的目录。如安装 ORACLE 数据库就可放到该目录下。默认为空</p>
<p>sbin	//Super User Binary，这里存放的是系统管理员使用的系统管理程序</p>
<p>selinux	//SELinux 是一种安全子系统，它能控制程序只能访问特定文件。</p>
<p>tmp	// 这个目录是用来存放一些临时文件的</p>
<p>lost+found	// 这个目录一般情况下是空，当系统非法关机后，这里就存放了一些文件。</p>
<p><strong><mark>重点：</mark></strong></p>
<p><strong>1.Linux 的目录中有且只有一个根目录。是 /</strong></p>
<p><strong>2.Linux 的各个目录存放的内容是规划好的，不要乱放文件。</strong></p>
<p><strong>3.Linux 是以文件的形式管理设备的，因此 Liux 系统，一切皆文件。</strong></p>
<p><strong>4.Linux 的各个文件目录下存放什么内容，必须有一个认识。</strong></p>
<h1 id="2使用xshell和xftp"><a class="markdownIt-Anchor" href="#2使用xshell和xftp">#</a> 2. 使用 XSHELL 和 XFTP</h1>
<p>1. 需要打开 Linux 的 SSHD 服务。服务器会开放默认端口 22 以供远程登录。</p>
<p>SSHD 开启方法：</p>
<p>Linux 系统下，使用 root 账户</p>
<p>setup</p>
<p>System servers</p>
<p><strong>XSHELL 设置：协议使用 SSH 协议，端口为默认端口 22，地址在服务器使用 ifconfig 查询</strong></p>
<p><strong>XFTP 设置：协议使用 SFTP，端口为默认端口 22，地址同上</strong></p>
<h1 id="3vi和vim编辑器"><a class="markdownIt-Anchor" href="#3vi和vim编辑器">#</a> 3.Vi 和 Vim 编辑器</h1>
<p><strong>Vi 和 Vim 的三种常见模式：</strong></p>
<p>1. 正常模式</p>
<p>可使用快捷键</p>
<p>2. 编辑模式 / 插入模式</p>
<p>正常模式下，按下 i,Io,O,a,A,r,R 等任何一个字母后进入编辑模式。</p>
<p>3. 命令行模式</p>
<p>插入模式下按 Esc 进入正常模式，按：或 / 进入命令行模式</p>
<p><strong>Vi 和 Vim 常用的快捷键（更多自行查询）</strong></p>
<p>yy，复制当前行，并向下粘贴。5yy 即粘贴 5 行。</p>
<p>dd，删除当前行。5dd 即删除当前行与向下的 4 行。</p>
<p>命令行下 / 关键字，查找第一个关键字，输入 n 查找下一个。</p>
<p>命令行下 set nu 开启行号，set nonu 关闭行号。</p>
<p>gg 前往首行，G 前往末行。注意这些都是在正常模式下的快捷键。</p>
<p>输入 u 撤销编辑内容到上次正常模式。</p>
<p>正常模式下，行号，shift+g 跳转到该行号</p>
<h1 id="4linux的关机-重启指令与用户的登录与注销"><a class="markdownIt-Anchor" href="#4linux的关机-重启指令与用户的登录与注销">#</a> 4.Linux 的关机、重启指令与用户的登录与注销</h1>
<p>shutdown -h now	表示立即关机</p>
<p>shutdown -h 1	表示 1 分钟后关机</p>
<p>shutdown -r now	表示立即重启</p>
<p>halt	停机，效果等价于关机</p>
<p>reboot	重启系统</p>
<p>sync	把内存数据同步到磁盘上（建议关机或重启前进行数据保存）</p>
<p>Linux 系统下通常不使用 root 账户登录，而是使用普通用户登录，再使用 su - 用户名进行登录</p>
<p>使用 logout 注销当前账户	logout 在图形运行级别无效，在运行级别 3 下有效</p>
<h1 id="5用户管理"><a class="markdownIt-Anchor" href="#5用户管理">#</a> 5. 用户管理</h1>
<h2 id="51部分指令"><a class="markdownIt-Anchor" href="#51部分指令">#</a> 5.1 部分指令</h2>
<p>1.Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>2.Linux 的用户需要至少属于一个组。</p>
<p><strong>添加用户 ([] 代表选填)：</strong></p>
<p><strong>useradd [] 用户名</strong></p>
<p>此时会在 home 下创建（用户名）家目录</p>
<p>若不指定组则自动创建同名组，并将用户归属于该组</p>
<p><strong>使用 user -g 组名 用户名	创建一个用户，并给他指定组</strong></p>
<p>若组不存在，则创建该组</p>
<p><strong>使用 useradd -d 指定目录 用户名	来指定用户的家目录创建位置</strong></p>
<p><strong>使用 passwd 用户名	给用户设置密码</strong>	注：设置密码过于简单会失败</p>
<p><strong>使用 userdel 用户名	来删除用户，该命令仅删除用户，不删除用户家目录</strong></p>
<p><strong>使用 userdel -r 用户名	删除用户及其家目录</strong></p>
<p><strong>使用 id 用户名	来查询用户信息</strong></p>
<p>获得信息 uid gid groups，为用户 id，组 id，和其所属组。</p>
<p><strong>使用 su - 用户名	可以切换用户</strong></p>
<p><strong>使用 exit 可以退回到原用户</strong></p>
<p><strong>使用 whoami	可以查看当前使用的用户</strong></p>
<h2 id="52用户组"><a class="markdownIt-Anchor" href="#52用户组">#</a> 5.2 用户组</h2>
<p><strong>使用 groupadd 组名	来创建一个组</strong></p>
<p><strong>使用 groupdel 组名	来删除一个组</strong></p>
<p><strong>使用 usermod -g 组名 用户名	修改用户的组</strong></p>
<h2 id="53用户信息和组信息的配置文件"><a class="markdownIt-Anchor" href="#53用户信息和组信息的配置文件">#</a> 5.3 用户信息和组信息的配置文件</h2>
<p>用户配置文件	/etc/passwd</p>
<p>组配置文件	/etc/group</p>
<p>口令配置文件 (加密)	/etc/shadow</p>
<h1 id="6运行级别共7级"><a class="markdownIt-Anchor" href="#6运行级别共7级">#</a> 6. 运行级别 (共 7 级)</h1>
<p>0：关机</p>
<p>1：单用户 (找回丢失密码)</p>
<p>2：多用户无网络服务</p>
<p>3：多用户有网络服务</p>
<p>4：暂空</p>
<p>5：图形界面</p>
<p>6：重启</p>
<p>如何找回丢失的 root 密码：</p>
<p>1. 进入到单用户模式（单用户模式登录不需要输入密码）</p>
<p>2. 修改 root 密码</p>
<p>在选择内核时输入 e，进入 GRUB 引导，选择 kernel 行，切换运行级别为 1，随后按 b</p>
<h1 id="7组管理和权限管理"><a class="markdownIt-Anchor" href="#7组管理和权限管理">#</a> 7. 组管理和权限管理</h1>
<h2 id="71组管理"><a class="markdownIt-Anchor" href="#71组管理">#</a> 7.1 组管理</h2>
<p>文件：</p>
<p>所有者 (拥有者)</p>
<p>所在组 (拥有组)</p>
<p>其他组</p>
<p><strong>ls -ahl	查看文件所有者</strong></p>
<p><strong>chown 用户名：组名 文件名	修改文件所有者、所有组，: 组名可以不改，-R 递归修改</strong></p>
<p><strong>chgrp 组名 文件名	修改文件所在组，-R 递归修改</strong></p>
<p><strong>usermod -g 组名 用户名	改变用户的组</strong></p>
<p><strong>usermod -d 目录名 用户名	改变该用户的初始登录目录</strong></p>
<h2 id="72权限管理重要"><a class="markdownIt-Anchor" href="#72权限管理重要">#</a> 7.2 权限管理 ==(重要！！)==</h2>
<p>查看一个文件时：</p>
<p><strong><mark>-rw-r–r--. 1 root root 6 12 月 13 22:34 ok.txt</mark></strong></p>
<p><strong>其中第 0 位 - 表示文件类型：- 普通文件，d: 目录，l: 软链接，c: 字符设备【键盘，鼠标】，b: 块文件【硬盘】</strong></p>
<p><strong>第 1-3 位中 rw - 表示文件所有者拥有的权限，r 为读，w 为写，x 为执行，- 为无权限</strong></p>
<p><strong>第 4-6 位中 r–表示文件所在组的用户的权限，同上</strong></p>
<p><strong>第 7-9 位中 r–表示文件的其他组的用户权限，同上</strong></p>
<p><strong><mark>1</mark></strong>，<strong>若为文件，表示硬链接，若为目录，则表示该目录中子目录的个数</strong></p>
<p><strong>第一个 root 为所有者，第二个 root 为所有组</strong></p>
<p><strong><mark>6</mark> 表示文件大小，如果是目录，则文件大小为 4096</strong></p>
<p><strong>12 月 13 22:34 表示文件最后的修改时间</strong></p>
<p><strong><mark>对文件有 w 权限，不代表能删除文件，必须有对其目录 w 的权限</mark></strong></p>
<p><strong>w 对于目录表示可以在目录内创建，删除，重命名目录</strong></p>
<p><strong>x 对于目录表示可以进入该目录</strong></p>
<p><strong>chmod	修改文件或目录的权限</strong></p>
<p><strong>u: 所有者，g: 所有组，o: 其他人，a: 所有人 (ugo 总和)</strong></p>
<p><strong><mark>user			group		other		all</mark></strong></p>
<p><strong>使用 +、-、= 变更权限</strong>，例：</p>
<p><strong>chmod u=rwx,g=rx,o=x 文件名 / 目录名</strong></p>
<p><strong>chmod o+w 文件名 / 目录名</strong></p>
<p><strong>chmod a-x 文件名 / 目录名</strong></p>
<p><strong>也可以使用数字更改权限</strong></p>
<p><strong><mark>r=4	w=2	x=1	rwx=4+2+1=7</mark></strong></p>
<p><strong>如：chmod 740 file	即给所有者 rwx，给所有组 r–，给其他组 —</strong></p>
<h1 id="8crond任务调度"><a class="markdownIt-Anchor" href="#8crond任务调度">#</a> 8.crond 任务调度</h1>
<p><strong>crontab [选项]</strong></p>
<p><strong>-e 编辑 crontab 定时任务</strong></p>
<p><strong>-l 查询 crontab 任务</strong></p>
<p><strong>-r 删除当前用户所有的 crontab 任务</strong></p>
<p><strong>service crond restart	重启任务调度</strong></p>
<p><strong>crontab -e 进入编辑界面</strong></p>
<p>**<mark>*/1 * * * * ls -l /etc/ &gt;&gt; /temp/to.txt</mark>** 每小时的每分钟执行 ls -l /etc/ &gt;&gt; /tmp/to.txt 命令</p>
<p><em><em>== 第一个</em>	一小时当中的第几分钟	范围 0-59==</em>*</p>
<p><em><em>== 第二个</em>	一天当中的第几个小时	范围 0-23==</em>*</p>
<p><em><em>== 第三个</em>	一个月当中的第几天	范围 1-31==</em>*</p>
<p><em><em>== 第四个</em>	一年当中的第几个月	范围 1-12==</em>*</p>
<p><em><em>== 第五个</em>	一周当中的星期几	范围 0-7 (0 和 7 都代表星期日)==</em>*</p>
<p><strong><mark>*	代表任何时间</mark></strong></p>
<p><strong><mark>,	代表不连续的时间，如 &quot;0 8,12,16 * * * 命令&quot;, 代表每天的 8 点 0 分，12 点 0 分，16 点 0 分都执行一次命令</mark></strong></p>
<p><strong><mark>-	代表连续的时间范围，如 &quot;0 5 * * 1-6 命令&quot;, 代表周一到周六的 5 点 0 分执行命令</mark></strong></p>
<p><strong><mark>*/n	代表每个多久执行一次，如 &quot;*/10 * * * * 命令&quot;, 代表每隔 10 分钟就执行一遍命令</mark></strong></p>
<h1 id="9linux磁盘分区与挂载"><a class="markdownIt-Anchor" href="#9linux磁盘分区与挂载">#</a> 9.Linux 磁盘分区与挂载</h1>
<p>分区方式包含:</p>
<p>1.mbr 分区 (传统)</p>
<p>最多支持 4 个主分区</p>
<p>系统智能安装在主分区</p>
<p>扩展分区要占一个主分区</p>
<p>MBR 最大只支持 2TB，但拥有最好的兼容性</p>
<p>2.gpt 分区</p>
<p>支持无限多个主分区 (但操作系统可能限制，比如 Windows 下最多 128 个分区)</p>
<p>最大支持 18EB (18*1024*1024TB) 的大容量</p>
<p>windows7 64 位以后支持 gpt</p>
<p>Linux 的分区是挂载 (mount) 到目录上的，卸载为 (unmount)。</p>
<p>Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘。</p>
<p>对于 IDE 硬盘，驱动器标识符为 &quot;hdx~&quot;，其中 &quot;hd&quot; 表明分区所在设备的类型，这里指 IDE 硬盘，“x&quot;为盘号，(a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘)，”~&quot; 代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区，hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。</p>
<p>对于 SCSI 硬盘则标识为 &quot;sdx~&quot;，SCSI 硬盘使用 &quot;sd&quot; 来表示分区所在设备的类型的，其余则和 IDE 硬盘一样</p>
<p><strong>lsblk -f	查看系统的分区和挂载的情况</strong></p>
<h1 id="10yum"><a class="markdownIt-Anchor" href="#10yum">#</a> 10.yum</h1>
<p>yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p>
<h1 id="11shell重要"><a class="markdownIt-Anchor" href="#11shell重要">#</a> 11.Shell**<mark>(重要！！)</mark>**</h1>
<p>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序。</p>
<h2 id="shell脚本格式"><a class="markdownIt-Anchor" href="#shell脚本格式">#</a> Shell 脚本格式</h2>
<p>1. 脚本以 #!/bin/bash 开头</p>
<p>2. 脚本需要有可执行权限</p>
<p>3. 可以用 #来写注释</p>
<p>4. 多行注释开头	:&lt;&lt;!	结尾	!</p>
<p>5.shell 变量定义时不要写空格</p>
<h2 id="shell的变量"><a class="markdownIt-Anchor" href="#shell的变量">#</a> shell 的变量</h2>
<p>1.Linux Shell 中的变量分为，系统变量和用户自定义变量。</p>
<p>2. 系统变量：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>O</mi><mi>M</mi><mi>E</mi><mtext>、</mtext></mrow><annotation encoding="application/x-tex">HOME、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">、</span></span></span></span>PWD、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>H</mi><mi>E</mi><mi>L</mi><mi>L</mi><mtext>、</mtext></mrow><annotation encoding="application/x-tex">SHELL、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">L</span><span class="mord mathnormal">L</span><span class="mord cjk_fallback">、</span></span></span></span>USER 等等，比如 echo $HOME</p>
<p>3. 显示当前 shell 中所有变量：set</p>
<p>4. 使用变量时前面要加 $</p>
<h2 id="shell变量的定义"><a class="markdownIt-Anchor" href="#shell变量的定义">#</a> shell 变量的定义</h2>
<p><strong><mark>基本语法：</mark></strong></p>
<p><strong>1. 定义变量：变量 = 值</strong></p>
<p><strong>2. 撤销变量：unset 变量</strong></p>
<p><strong>3. 声明静态变量：readonly 变量，注意：不能 unset</strong></p>
<p><strong>4. 可以把一个变量提升为全局变量，可供其他 shell 程序使用</strong></p>
<p><strong><mark>变量定义规则：</mark></strong></p>
<p><strong>1. 变量名称可以由字母、数字与下划线组成，但不能以数字开头</strong></p>
<p><strong>2. 等号两侧不能有空格</strong></p>
<p><strong>3. 变量名称一般习惯为大写</strong></p>
<p><strong><mark>将命令的返回值赋给变量</mark></strong></p>
<p><strong>1.A=`ls -la`	反引号，运行里面的命令，并把结果返回给变量 A</strong></p>
<p><strong>2.A=$(ls -la)	等价于反引号</strong></p>
<p><strong><mark>设置环境变量语法与注意</mark></strong></p>
<p><strong>1.export 变量名 = 变量值	将 shell 变量输出为环境变量</strong></p>
<p><strong>2.source 配置文件	让修改后的配置信息立即生效 (source /etc/profile)</strong></p>
<p><strong>3.echo $ 变量名	查询环境变量的值</strong></p>
<p><strong>注意：在输出 JAVA_HOME 环境变量前，需要让其生效</strong></p>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记</title>
    <url>/2023/02/24/java/</url>
    <content><![CDATA[<h1 id="注java的相当一部分语法可以参考c语言笔记"><a class="markdownIt-Anchor" href="#注java的相当一部分语法可以参考c语言笔记">#</a> 注：Java 的相当一部分语法可以参考 C 语言笔记</h1>
<h1 id="一java环境搭建"><a class="markdownIt-Anchor" href="#一java环境搭建">#</a> <mark>一.Java 环境搭建</mark></h1>
<p>JDK (Java Development Kit 	Java 开发工具包)</p>
<p>JRE (Java Runtime Environment 	Java 运行环境)</p>
<p>JVM (Java Virtual Machine	 Java 虚拟机)</p>
<p><mark><strong>将 JDK 的 bin 文件目录加入到系统环境变量 path 中。</strong></mark></p>
<p><strong>具体操作：此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 编辑 path</strong></p>
<p><mark><strong>或者：将 JDK 目录添加到系统环境变量，通常设置此变量名为 JAVA_HOME。然后在 path 中添加 % JAVA_HOME%\bin</strong></mark></p>
<p><mark><strong>使用 javac fileName.java 对 java 文件进行编译</strong></mark></p>
<p><mark><strong>使用 java ClassName 对编译好的二进制文件进行执行</strong></mark></p>
<p><mark><strong>使用 javac -encoding utf8 fileName.java 可以对 utf8 的文件进行编译</strong></mark></p>
<h1 id="二java语法"><a class="markdownIt-Anchor" href="#二java语法">#</a> <mark>二.Java 语法</mark></h1>
<h2 id="1注释"><a class="markdownIt-Anchor" href="#1注释">#</a> 1. 注释</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">文档注释</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">这是java特有的文档注释的写法，这些注释内容可以被jdk自带的javadoc解析，生成一个网页，供人参考</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>java 源文件中可以声明多个类。但是最多只能有一个类声明为 public。</strong></p>
<p><strong>而且要求声明为 public 的类的类名必须与愿望呢简明相同。</strong></p>
<h2 id="2类与方法函数"><a class="markdownIt-Anchor" href="#2类与方法函数">#</a> <mark>2. 类与方法 (函数)</mark></h2>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">import</td>
<td style="text-align:center">导入包，同 Python</td>
</tr>
<tr>
<td style="text-align:center">System.out.println(msg)</td>
<td style="text-align:center">控制窗口输出函数</td>
</tr>
<tr>
<td style="text-align:center"><span class="exturl" data-url="aHR0cDovL1N5c3RlbS5pbg==">System.in</span></td>
<td style="text-align:center">从控制窗口读取</td>
</tr>
</tbody>
</table>
<h3 id="1scanner类"><a class="markdownIt-Anchor" href="#1scanner类">#</a> (1) Scanner 类</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">该类位于 java.util.Scanner 包中，需要先导入</td>
<td style="text-align:center">用法: Scanner scan = new Scanner (<span class="exturl" data-url="aHR0cDovL1N5c3RlbS5pbg==">System.in</span>);</td>
</tr>
<tr>
<td style="text-align:center">next();</td>
<td style="text-align:center">该方法可以获取键入的字符串</td>
</tr>
<tr>
<td style="text-align:center">nextInt();</td>
<td style="text-align:center">获取键入的整形，double，long 等同理</td>
</tr>
</tbody>
</table>
<h3 id="2string类"><a class="markdownIt-Anchor" href="#2string类">#</a> (2) String 类</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">charAt(int Index);</td>
<td style="text-align:center">从字符串中读取相应 index 的字符</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="3"><a class="markdownIt-Anchor" href="#3">#</a> (3)</h3>
<h2 id="3运算符参考c语言"><a class="markdownIt-Anchor" href="#3运算符参考c语言">#</a> 3. 运算符 (参考 C 语言)</h2>
<p><mark><strong>参考 C 语言笔记，与 C 语言的运算符几乎完全相同</strong></mark></p>
<h2 id="4if-while-switch等结构参考c语言"><a class="markdownIt-Anchor" href="#4if-while-switch等结构参考c语言">#</a> 4.if、while、switch 等结构 (参考 C 语言)</h2>
<p><mark><strong>参考 C 语言笔记，与 C 语言的运算符几乎完全相同</strong></mark></p>
<h2 id="5数组"><a class="markdownIt-Anchor" href="#5数组">#</a> <mark>5. 数组</mark></h2>
<h3 id="1数组创建"><a class="markdownIt-Anchor" href="#1数组创建">#</a> (1) 数组创建</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java创建一个数组的方法</span></span><br><span class="line"><span class="comment">//方法1：</span></span><br><span class="line">dataType[] arrayName;</span><br><span class="line">arrayName = <span class="keyword">new</span> <span class="title class_">dataType</span>[]&#123;data1, data2, data3&#125;;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">dataType[] arrayName = <span class="keyword">new</span> <span class="title class_">dataType</span>[elementsNumber];</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//创建一个长度为10的整型数组</span></span><br></pre></td></tr></table></figure>
<h3 id="2其他"><a class="markdownIt-Anchor" href="#2其他">#</a> (2) 其他</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arrayName.length;<span class="comment">//获取数组的长度</span></span><br><span class="line"><span class="comment">//遍历并初始化一个整型数组</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">    array[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三"><a class="markdownIt-Anchor" href="#三">#</a> 三.</h1>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>这是我的第一个帖子</title>
    <url>/2023/02/19/My-first-Post/</url>
    <content><![CDATA[<h1 id="这是一个测试帖子"><a class="markdownIt-Anchor" href="#这是一个测试帖子">#</a> 这是一个测试帖子</h1>
<h2 id="也是我的第一个帖子"><a class="markdownIt-Anchor" href="#也是我的第一个帖子">#</a> 也是我的第一个帖子</h2>
]]></content>
      <tags>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML+CSS</title>
    <url>/2023/02/22/HTML-CSS/</url>
    <content><![CDATA[<h1 id="1html的概念"><a class="markdownIt-Anchor" href="#1html的概念">#</a> 1.HTML 的概念</h1>
<p>HTML (Hyper Text Markup Language)	超文本标记语言</p>
<h1 id="2html语法"><a class="markdownIt-Anchor" href="#2html语法">#</a> <mark>2.HTML 语法</mark></h1>
<p><mark><strong>&lt;关键词&gt; 内容 &lt;/ 关键词 (结束)&gt;</strong></mark></p>
<p><strong>例如：</strong></p>
<p><strong>&lt;strong&gt; 加粗显示 &lt;/strong&gt;</strong></p>
<p><mark><strong>注释</strong></mark></p>
<p><strong>&lt;!-- 注释内容 --&gt;</strong></p>
<h3 id="关键词"><a class="markdownIt-Anchor" href="#关键词">#</a> <mark><strong>关键词</strong></mark></h3>
<p><strong>br	换行</strong></p>
<p><strong>hr	水平分割线</strong></p>
<p><strong>h1~h6	1~6 级标题</strong></p>
<p><strong>p	段落</strong></p>
<p><strong>/</strong>*</p>
<p><strong>b = strong	加粗</strong></p>
<p><strong>u = ins	下划线</strong></p>
<p><strong>i = em	倾斜</strong></p>
<p><strong>s = del	删除线</strong></p>
<p>*<strong>/	// 后者突出重要性的强调语境 (视觉效果无差别)</strong></p>
<h3 id="媒体标签"><a class="markdownIt-Anchor" href="#媒体标签">#</a> <mark><strong>媒体标签</strong></mark></h3>
<p><strong><mark>&lt;img&gt;	在网页中显示图片，以下为 img 属性，每个属性之间用空格隔开</mark></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">src=&quot; &quot;</td>
<td style="text-align:center">填写图片路径</td>
</tr>
<tr>
<td style="text-align:center">alt=&quot; &quot;</td>
<td style="text-align:center">填写图片加载失败时的替换文本</td>
</tr>
<tr>
<td style="text-align:center">title=&quot; &quot;</td>
<td style="text-align:center">为鼠标悬停提示文字</td>
</tr>
<tr>
<td style="text-align:center">width=&quot; &quot;</td>
<td style="text-align:center">图片宽度，单位为像素  (仅填写其中一个时，会等比例缩放)</td>
</tr>
<tr>
<td style="text-align:center">height=&quot; &quot;</td>
<td style="text-align:center">图片高度，单位为像素  (仅填写其中一个时，会等比例缩放)</td>
</tr>
</tbody>
</table>
<p><strong><mark>&lt;audio&gt;&lt;/audio&gt;	在网页中插入音频，以下为 audio 属性</mark></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">src=&quot; &quot;</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">controls</td>
<td style="text-align:center">显示音频播放控件</td>
</tr>
<tr>
<td style="text-align:center">autoplay</td>
<td style="text-align:center">自动播放 (部分浏览器不支持)</td>
</tr>
<tr>
<td style="text-align:center">loop</td>
<td style="text-align:center">循环播放</td>
</tr>
</tbody>
</table>
<p><strong>注：音频标签目前支持三种格式：MP3、Wav、Ogg</strong></p>
<p><strong><mark>&lt;video&gt;	在网页中显示视频，以下为 video 属性</mark></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">src=&quot; &quot;</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">controls</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">autoplay</td>
<td style="text-align:center">同上     (Google 浏览器中需要配合 muted 实现静音播放)</td>
</tr>
<tr>
<td style="text-align:center">loop</td>
<td style="text-align:center">同上</td>
</tr>
</tbody>
</table>
<p><strong>注：视频标签目前支持三种格式：MP4、WebM、Ogg</strong></p>
<h3 id="链接标签"><a class="markdownIt-Anchor" href="#链接标签">#</a> <mark><strong>链接标签</strong></mark></h3>
<p><strong>&lt;a href=&quot;./ 目标网页.html&quot;&gt; 文字提示 &lt;/a&gt;	以下为超链接属性</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">target=&quot; &quot;</td>
<td style="text-align:center">若填写_self (默认值)，覆盖原网页跳转，若填写_blank, 保留原网页跳转</td>
</tr>
<tr>
<td style="text-align:center">href=&quot; &quot;</td>
<td style="text-align:center">填写目标网页路径</td>
</tr>
</tbody>
</table>
<p><strong>注：跳转网页未写好 (不知道要跳转到哪里) 时，href 里填写 #(空链接)</strong></p>
<h3 id="列表标签"><a class="markdownIt-Anchor" href="#列表标签">#</a> <mark><strong>列表标签</strong></mark></h3>
<p><strong>无序列表：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ul</td>
<td style="text-align:center">表示无序列表的整体，用于包裹 li 标签</td>
</tr>
<tr>
<td style="text-align:center">li</td>
<td style="text-align:center">表示无序列表的每一项，用于包含每一行的内容</td>
</tr>
</tbody>
</table>
<p><strong>显示特点：列表的每一项前默认显示圆点标识</strong></p>
<p><strong>注：ul 标签中只允许包含 li 标签，li 标签可以包含任意内容</strong></p>
<p><strong>有序列表：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ol</td>
<td style="text-align:center">表示有序里列表的整体，用于包裹 li 标签</td>
</tr>
<tr>
<td style="text-align:center">li</td>
<td style="text-align:center">表示有序列表的每一项，用于包含每一行的内容</td>
</tr>
</tbody>
</table>
<p><strong>显示特点：列表的每一项前默认显示序号标识</strong></p>
<p><strong>注：ol 标签中只允许包含 li 标签，li 标签可以包含任意内容</strong></p>
<p><strong>自定义列表：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">dl</td>
<td style="text-align:center">表示自定义列表的整体，用于包裹 dt/dd 标签</td>
</tr>
<tr>
<td style="text-align:center">dt</td>
<td style="text-align:center">表示自定义列表的主题</td>
</tr>
<tr>
<td style="text-align:center">dd</td>
<td style="text-align:center">表示自定义列表的针对主题的每一项内容</td>
</tr>
</tbody>
</table>
<p><strong>显示特点：dd 前会默认显示缩进效果</strong></p>
<p><strong>注：dl 标签只允许包含 dt/dd 标签，dt/dd 标签可以包含任意内容</strong></p>
<h3 id="表格标签"><a class="markdownIt-Anchor" href="#表格标签">#</a> <mark><strong>表格标签</strong></mark></h3>
<p><strong>基本标签：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">表格整体，可用于包裹多个 tr</td>
</tr>
<tr>
<td style="text-align:center">tr</td>
<td style="text-align:center">表格每行，可用于包裹 td</td>
</tr>
<tr>
<td style="text-align:center">td</td>
<td style="text-align:center">表格单元格，可用于包裹内容</td>
</tr>
</tbody>
</table>
<p><strong>注：标签嵌套：table &gt; tr &gt; td</strong></p>
<p><strong>表格属性：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">属性值</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">border</td>
<td style="text-align:center">数字</td>
<td style="text-align:center">边框宽度</td>
</tr>
<tr>
<td style="text-align:center">width</td>
<td style="text-align:center">数字</td>
<td style="text-align:center">表格宽度</td>
</tr>
<tr>
<td style="text-align:center">height</td>
<td style="text-align:center">数字</td>
<td style="text-align:center">表格高度</td>
</tr>
</tbody>
</table>
<p><strong>注：实际开发时针对于样式效果<mark>推荐使用 CSS 设置</mark></strong></p>
<p><strong>表格其他标签：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">caption</td>
<td style="text-align:center">表格大标题</td>
<td style="text-align:center">表示表格整体大标题，默认在表格整体顶部居中显示</td>
</tr>
<tr>
<td style="text-align:center">th</td>
<td style="text-align:center">表头单元格</td>
<td style="text-align:center">表示一列小标题，通常用于表格第一行，默认内部文字加粗居中</td>
</tr>
</tbody>
</table>
<p><strong>注：caption 标签写在 table 标签内部，th 标签写在 tr 标签内部</strong></p>
<p><strong>表格结构：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">thead</td>
<td style="text-align:center">表格头</td>
</tr>
<tr>
<td style="text-align:center">tbody</td>
<td style="text-align:center">表格内容</td>
</tr>
<tr>
<td style="text-align:center">tfoot</td>
<td style="text-align:center">表格底</td>
</tr>
</tbody>
</table>
<p><strong>注：不会产生网页视觉改变，但可以提高浏览器解析速度</strong></p>
<p><strong>合并单元格：</strong></p>
<p><strong>给保留的单元格添加属性：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">属性值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">rowspan</td>
<td style="text-align:center">合并单元格的个数</td>
<td style="text-align:center">跨行合并，将多行的单元格垂直合并</td>
</tr>
<tr>
<td style="text-align:center">colspan</td>
<td style="text-align:center">合并单元格的个数</td>
<td style="text-align:center">跨列合并，将多列的单元格垂直合并</td>
</tr>
</tbody>
</table>
<p><strong>注：同结构下才可合并，不可跨结构合并 (不可跨 thead、tbody、tfoot)</strong></p>
<h3 id="表单标签"><a class="markdownIt-Anchor" href="#表单标签">#</a> <mark><strong>表单标签</strong></mark></h3>
<p><strong>写登陆、注册、搜索功能时使用</strong></p>
<p><mark><strong>表单域标签</strong></mark></p>
<table>
<thead>
<tr>
<th style="text-align:center">&lt;form action=&quot; &quot;&gt;&lt;/form&gt;</th>
<th style="text-align:center">action 中填写数据提交的地址，此为表单的父标签</th>
</tr>
</thead>
</table>
<p><strong><mark>input 标签</mark>可以通过不同的 type=&quot; &quot; 属性值，展示不同的效果：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">type 属性值</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">属性名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">input</td>
<td style="text-align:center">text</td>
<td style="text-align:center">文本框，用于输入单行文本</td>
<td style="text-align:center">placeholder</td>
<td style="text-align:center">占位符。提示用户输入内容的文本</td>
</tr>
<tr>
<td style="text-align:center">input</td>
<td style="text-align:center">password</td>
<td style="text-align:center">密码框，用于输入密码</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">input</td>
<td style="text-align:center">radio</td>
<td style="text-align:center">单选框，用于多选一</td>
<td style="text-align:center">name</td>
<td style="text-align:center">分组。有相同 name 属性值的单选框为一组，一组中同时只能有一个被选中</td>
</tr>
<tr>
<td style="text-align:center">input</td>
<td style="text-align:center">checkbox</td>
<td style="text-align:center">多选框，用于多选多</td>
<td style="text-align:center">checked</td>
<td style="text-align:center">默认选中</td>
</tr>
<tr>
<td style="text-align:center">input</td>
<td style="text-align:center">file</td>
<td style="text-align:center">文件选择，用于之后上传文件</td>
<td style="text-align:center">multiple</td>
<td style="text-align:center">多文件选择</td>
</tr>
<tr>
<td style="text-align:center">input</td>
<td style="text-align:center">submit</td>
<td style="text-align:center">提交按钮，用于提交</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">input</td>
<td style="text-align:center">reset</td>
<td style="text-align:center">重置按钮，用于重置</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">input</td>
<td style="text-align:center">button</td>
<td style="text-align:center">普通按钮，默认无功能，需配合 js 使用</td>
<td style="text-align:center">value</td>
<td style="text-align:center">给按钮添加提示文字</td>
</tr>
</tbody>
</table>
<p><strong>注：button 可作为一个标签使用，作为标签使用时，谷歌浏览器默认为提交按钮，可以用 type 属性修改其功能。button 为双标签，可以用于包裹文字、图片等内容</strong></p>
<p><strong><mark>selct 标签</mark>下拉菜单：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">select</td>
<td style="text-align:center">下拉菜单的整体</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">option</td>
<td style="text-align:center">下拉菜单的每一项</td>
<td style="text-align:center">selected</td>
<td style="text-align:center">默认选中</td>
</tr>
</tbody>
</table>
<p><strong><mark>textarea 文本域标签</mark>可在网页中提供可输入多行文本的表单控件</strong></p>
<p><strong>可以使用 cols、rows 属性修改文本域内可见列和可见行、但一般使用 CSS 修改</strong></p>
<p><strong>注：右下角可以拖拽改变大小、可以通过 CSS 禁用</strong></p>
<p><strong><mark>label 标签</mark>可以用于绑定内容与表单标签的关系</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">label</td>
<td style="text-align:center">for</td>
<td style="text-align:center">for 中填写的内容绑定   属性 id 填写内容相同的标签</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><strong>也可以将 for 属性删除，使用 label 标签将需要绑定的内容直接包裹</strong></td>
</tr>
</tbody>
</table>
<h3 id="语义化标签"><a class="markdownIt-Anchor" href="#语义化标签">#</a> <mark><strong>语义化标签</strong></mark></h3>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">div</td>
<td style="text-align:center">无语义标签，内容独占一行、配合 css 使用</td>
</tr>
<tr>
<td style="text-align:center">span</td>
<td style="text-align:center">无语义标签，内容不换行、配合 css 使用</td>
</tr>
<tr>
<td style="text-align:center">---------</td>
<td style="text-align:center">以下标签为手机网页使用。</td>
</tr>
<tr>
<td style="text-align:center">header</td>
<td style="text-align:center">网页头部</td>
</tr>
<tr>
<td style="text-align:center">nav</td>
<td style="text-align:center">网页导航</td>
</tr>
<tr>
<td style="text-align:center">footer</td>
<td style="text-align:center">网页底部</td>
</tr>
<tr>
<td style="text-align:center">aside</td>
<td style="text-align:center">网页侧边栏</td>
</tr>
<tr>
<td style="text-align:center">section</td>
<td style="text-align:center">网页区块</td>
</tr>
<tr>
<td style="text-align:center">article</td>
<td style="text-align:center">网页文章</td>
</tr>
</tbody>
</table>
<p><mark>字符实体</mark></p>
<p>注：网页不识别代码中连续的空格， 若要实现，需使用 &amp; nbsp</p>
<h1 id="3html结构"><a class="markdownIt-Anchor" href="#3html结构">#</a> 3.HTML 结构</h1>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>		<span class="comment">&lt;!--文档类型声明，告诉浏览器该网页的HTML版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>	<span class="comment">&lt;!--语言，en为英文，中文为zh-CN--&gt;</span></span><br><span class="line">​	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>	<span class="comment">&lt;!--规定网页的字符编码.UTF-8(万国码),GB2312:6000+汉字，GBK:20000+汉字--&gt;</span> </span><br><span class="line">    </span><br><span class="line">    	<span class="comment">&lt;!--下面这行代码用于兼容IE浏览器--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">&lt;!--content&quot;宽度=设备宽度&quot;，移动端需要设置--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">&lt;!--title，description与Keywords为SEO三大标签(用于优化在搜索引擎中的排名)--&gt;</span></span><br><span class="line">​		<span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;此处填写对网页的描述，用于提升在搜索引擎中的排名&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;此处填写网页关键词，用于提升在搜索引擎中的排名&quot;</span>&gt;</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">&lt;!--网站标题旁的小图标，通常放置于根目录--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"><span class="comment">/*Css内容*/</span></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">​	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">​	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">​		网页内容主体</span><br><span class="line">​	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="4css的概念"><a class="markdownIt-Anchor" href="#4css的概念">#</a> 4.CSS 的概念</h1>
<p>CSS：层叠样式表 (Cascading style sheets)</p>
<p>CSS 的作用：给页面中的 HTML 标签设置样式</p>
<h1 id="5css语法"><a class="markdownIt-Anchor" href="#5css语法">#</a> <mark>5.CSS 语法</mark></h1>
<p><strong>内嵌式：将 CSS 写在 style 标签中，style 标签一般写在 head 标签内，title 标签下面</strong></p>
<p><strong>外联式：将 CSS 写在一个单独的.css 文件中，在 title 标签下使用 link 标签引入</strong></p>
<p><mark>注：link rel=“此处填入 html 与 css 的关系 (为：stylesheet  样式表)” href=“此处填写 css 文件路径”</mark></p>
<p><strong>行内式：将 CSS 写在标签内的 style 属性内，通常配合 JS 使用</strong></p>
<h3 id="选择器写法"><a class="markdownIt-Anchor" href="#选择器写法">#</a> <mark>选择器写法</mark></h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*标签选择器写法*/</span></span><br><span class="line">标签名&#123;<span class="comment">/*使用要改变的html相同的标签*/</span></span><br><span class="line">    <span class="attribute">color</span>: red;<span class="comment">/*此为CSS属性*/</span></span><br><span class="line">    <span class="comment">/*color是属性名，red为属性值*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*类选择器写法*/</span></span><br><span class="line">.类名&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">写<span class="selector-tag">html</span>时，写属性class=&quot;类名&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*id选择器写法*/</span></span><br><span class="line"><span class="selector-id">#id</span>属性名&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">写<span class="selector-tag">html</span>时，写属性id=&quot;属性名&quot;</span><br><span class="line">注意：id选择器通常配合js使用，且在<span class="selector-tag">html</span>中只能使用一次，多次使用是不合法的。</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通配符选择器写法*/</span></span><br><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">改变所有的<span class="selector-tag">html</span>样式</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上面为基础写法，下面为基础选择器的拓展写法,选择名可以是以上任意形式*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*后代选择器*/</span></span><br><span class="line">选择名<span class="number">1</span> 选择名<span class="number">2</span>&#123;</span><br><span class="line">    css</span><br><span class="line">&#125;</span><br><span class="line">例如：</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">只要是<span class="selector-tag">div</span>下包含的<span class="selector-tag">p</span>标签就会生效。</span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">	&lt;<span class="selector-tag">p</span>&gt;变红&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">	&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">p</span>&gt;变红&lt;/<span class="selector-tag">p</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子代选择器*/</span></span><br><span class="line">选择名<span class="number">1</span>&gt;选择名<span class="number">2</span>&#123;</span><br><span class="line">    css</span><br><span class="line">&#125;</span><br><span class="line">例如：</span><br><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">只作用于选择名<span class="number">1</span>下的最高级选择名<span class="number">2</span>.</span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">	&lt;<span class="selector-tag">p</span>&gt;变红&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">	&lt;<span class="selector-tag">span</span>&gt;&lt;<span class="selector-tag">p</span>&gt;不变红&lt;/<span class="selector-tag">p</span>&gt;&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*并集选择器*/</span></span><br><span class="line">选择名<span class="number">1</span>,选择名<span class="number">2</span> &#123;</span><br><span class="line">    css</span><br><span class="line">&#125;</span><br><span class="line">将选择名<span class="number">1</span>，选择名<span class="number">2</span>，均执行css</span><br><span class="line"></span><br><span class="line"><span class="comment">/*交集选择器*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.class</span> &#123;<span class="comment">/*p与.class之间不能有空格之类的字符*/</span></span><br><span class="line">    css</span><br><span class="line">&#125;</span><br><span class="line">将包含class类的<span class="selector-tag">p</span>标签执行css</span><br><span class="line">&lt;<span class="selector-tag">p</span> class=&quot;class&quot;&gt;执行css&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*hover伪类选择器*/</span></span><br><span class="line">选择名<span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    css</span><br><span class="line">&#125;</span><br><span class="line">鼠标悬停在选择名时，执行CSS。</span><br><span class="line">例如：</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;鼠标悬停在此时，该文字显示为红色&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><mark><strong>结构伪类选择器</strong></mark></p>
<table>
<thead>
<tr>
<th style="text-align:center">选择器</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">E:first-child{}</td>
<td style="text-align:center">匹配 E 元素中的第一个</td>
</tr>
<tr>
<td style="text-align:center">E:last-child{}</td>
<td style="text-align:center">匹配 E 元素中的最后一个</td>
</tr>
<tr>
<td style="text-align:center">E:nth-child(n){}</td>
<td style="text-align:center">匹配 E 元素中的第 n 个，n 处可填公式</td>
</tr>
<tr>
<td style="text-align:center">E:nth-last-child(n){}</td>
<td style="text-align:center">匹配 E 元素中的倒数第 n 个，n 处可填公式</td>
</tr>
<tr>
<td style="text-align:center">公式中的 n 从 0 开始</td>
<td style="text-align:center">公式：偶数：2n、even。奇数：2n+1、2n-1、odd</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">公式：找到前 5 个：-n+5、找到从第 5 个往后：n+5</td>
</tr>
</tbody>
</table>
<h3 id="伪元素"><a class="markdownIt-Anchor" href="#伪元素">#</a> <mark><strong>伪元素</strong></mark></h3>
<p><strong>(使用 css 创建标签，通常用于装饰性，不重要的小图)</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">伪元素</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">::before</td>
<td style="text-align:center">在父元素内容的最前添加一伪元素</td>
</tr>
<tr>
<td style="text-align:center">::after</td>
<td style="text-align:center">在父元素内容的最后添加一伪元素</td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.exmaple</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;前缀内容&#x27;</span>;</span><br><span class="line">    <span class="comment">/*默认为行内元素，宽高不生效*/</span></span><br><span class="line">    <span class="comment">/*content属性必须添加，否则不生效，内容可以留空*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浮动"><a class="markdownIt-Anchor" href="#浮动">#</a> <mark><strong>浮动</strong></mark></h3>
<p><strong>float: left/right</strong></p>
<p><strong>1. 添加 float 属性的标签会脱离标准流的控制，不再占用标准流的位置</strong></p>
<p><strong>2. 浮动元素比标准流高半个级别，可以覆盖标准流中的元素，但不能覆盖其内容</strong></p>
<p><strong>3. 浮动的标签默认顶对齐，可以通过 margin 修改位置</strong></p>
<p><strong>4. 浮动元素不换行，可以设置宽高。浮动后标签具有行内块的特点。</strong></p>
<p><strong>5. 浮动后的元素，不能使用 margin: 0 auto。</strong></p>
<p><mark><strong>清除浮动给别的标签带来的影响</strong></mark></p>
<p>影响：子元素浮动时，不能撑开标准流的块。</p>
<p>方法 1：</p>
<p><strong>在父元素内容的最后添加一个块级元素</strong></p>
<p><strong>给添加的块级元素设置 clear:both</strong></p>
<p>方法 2：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*单伪元素清除法*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="comment">/*添加以下代码，在网页中看不到伪元素*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法 3：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*before用于解决外边距塌陷问题*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法 4：</p>
<p><strong>给父元素设置 overflow: hidden;</strong></p>
<p>注：此方法也可用于外边距塌陷</p>
<h3 id="css属性"><a class="markdownIt-Anchor" href="#css属性">#</a> <mark>CSS 属性</mark></h3>
<h4 id="font系列"><a class="markdownIt-Anchor" href="#font系列">#</a> <mark><strong>font 系列：</strong></mark></h4>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">font-style</td>
<td style="text-align:center">控制字体格式，normal 为正常，italic 为斜体</td>
</tr>
<tr>
<td style="text-align:center">font-weight</td>
<td style="text-align:center">控制字体粗细，normal 正常 (400)，bold 加粗 (700)，或使用 100-900 的数字控制</td>
</tr>
<tr>
<td style="text-align:center">font-size</td>
<td style="text-align:center">控制字体大小，单位 px (像素)、谷歌浏览器默认大小是 16px</td>
</tr>
<tr>
<td style="text-align:center">line-height</td>
<td style="text-align:center">控制行高，可以填数字 + px，也可以只填数字 (当前标签的 font-size 的倍数)</td>
</tr>
<tr>
<td style="text-align:center">font-family</td>
<td style="text-align:center">控制字体，windows 默认微软雅黑</td>
</tr>
<tr>
<td style="text-align:center">color</td>
<td style="text-align:center">控制字体颜色</td>
</tr>
</tbody>
</table>
<p><strong>font 可缩写为：</strong></p>
<p><strong>font: style weight size/line-height family;    其中 style 和 weight 可省略，size/line-height 不是二选其一的意思</strong></p>
<hr>
<h4 id="text系列"><a class="markdownIt-Anchor" href="#text系列">#</a> <mark><strong>text 系列：</strong></mark></h4>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">text-align</td>
<td style="text-align:center">控制内容水平对齐方式，left 左对齐，center 居中，right 右对齐。</td>
</tr>
<tr>
<td style="text-align:center">text-indent</td>
<td style="text-align:center">控制段落首行缩进，单位可以是 px，也可以是 em (1em = 当前标签的 font-size 的大小)</td>
</tr>
<tr>
<td style="text-align:center">text-decoration</td>
<td style="text-align:center">underline 下划线，line-through 删除线，overline 上划线，none 无装饰线</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="background系列"><a class="markdownIt-Anchor" href="#background系列">#</a> <mark><strong>background 系列：</strong></mark></h4>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">background-color</td>
<td style="text-align:center">控制背景颜色</td>
</tr>
<tr>
<td style="text-align:center">background-image： url (此处填写图片地址)</td>
<td style="text-align:center">控制背景图片</td>
</tr>
<tr>
<td style="text-align:center">background-repeat</td>
<td style="text-align:center">平铺背景图片，默认 repeat (平铺)，no-repeat (不平铺)，repeat-x (按 x 轴平铺，改成 y 按 y 轴)</td>
</tr>
<tr>
<td style="text-align:center">background-position: 水平 垂直</td>
<td style="text-align:center">控制背景位置，可以用英语单词 (top 上，bottom 下)，也可以使用坐标系 (单位 px)</td>
</tr>
<tr>
<td style="text-align:center">background-size: 宽 高</td>
<td style="text-align:center">取值为数字、或百分比 (相对于当前盒子的宽高)、contain、cover</td>
</tr>
<tr>
<td style="text-align:center">width</td>
<td style="text-align:center">控制宽度，单位 px</td>
</tr>
<tr>
<td style="text-align:center">height</td>
<td style="text-align:center">控制高度，单位 px</td>
</tr>
</tbody>
</table>
<p><strong>background 可简写为:</strong></p>
<p><strong>background: color image repeat position    其中属性不分先后顺序，但推荐按照该顺序书写</strong></p>
<p><strong>例：background: pink url (./image.jpg) no-repeat right bottom</strong></p>
<p><strong>颜色：rgba (0,0,0,0),rgb 是红绿蓝，范围 0-255，a 是透明度，范围 0-1。</strong></p>
<hr>
<h3 id="css属性通常书写顺序"><a class="markdownIt-Anchor" href="#css属性通常书写顺序">#</a> <mark>CSS 属性通常书写顺序</mark></h3>
<p><strong>1. 浮动 /display</strong></p>
<p><strong>2. 盒子模型：margin border padding 宽高背景色</strong></p>
<p><strong>3. 文字样式</strong></p>
<h3 id="css常用配置basecss"><a class="markdownIt-Anchor" href="#css常用配置basecss">#</a> <mark>CSS 常用配置 (base.css)</mark></h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*清除浏览器默认内外边距，设置为内减模式*/</span></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设置网页统一的字体大小、行高、字体系列相关属性*/</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">16px</span>/<span class="number">1.5</span> <span class="string">&quot;Helvetica Neue&quot;</span>, Helvetica,Arial, <span class="string">&quot;Microsoft Yahei&quot;</span>, <span class="string">&quot;Hiragion Sans GB&quot;</span>, <span class="string">&quot;Heiti SC&quot;</span>, <span class="string">&quot;WenQuanYi Micro Hei&quot;</span>, sans-serif;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;<span class="comment">/*可改*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*清除超链接的下划线*/</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;<span class="comment">/*可改*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*去除默认的倾斜效果*/</span></span><br><span class="line"><span class="selector-tag">em</span>,</span><br><span class="line"><span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*清除列表的圆点*/</span></span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">ol</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设置img的垂直对齐方式为居中对齐，去除img默认的下间隙*/</span></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*去除input默认样式*/</span></span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;<span class="comment">/*可改*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*左右浮动*/</span></span><br><span class="line"><span class="selector-class">.fl</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fr</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*clearfix，用于修复塌陷与清除浮动影响*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6网页布局与vs-code使用技巧"><a class="markdownIt-Anchor" href="#6网页布局与vs-code使用技巧">#</a> 6. 网页布局与 Vs Code 使用技巧</h1>
<h3 id="元素显示模式"><a class="markdownIt-Anchor" href="#元素显示模式">#</a> <mark>元素显示模式</mark></h3>
<p><strong>块级元素：</strong></p>
<p><strong>独占一行，宽度默认为父级标签的 100%，允许使用 width 和 height 调整宽高</strong></p>
<p><strong>代表标签：div、p、h 系列、ul、li、dl、dt、dd、form、header、nav、footer…</strong></p>
<p><strong>行内元素：</strong></p>
<p><strong>一行可以显示多个，宽高默认由内容撑开，不可以设置宽高</strong></p>
<p><strong>代表标签：span、a、b、u、i、s、strong、ins、em、del…</strong></p>
<p><strong>行内块元素：</strong></p>
<p><strong>一行可以显示多个，允许设置宽高。若未设置宽高，则由内容撑开，无内容则不显示</strong></p>
<p><strong>代表标签：img、input、textarea、button、select…</strong></p>
<p><strong>元素显示模式转换：(目的：改变元素默认的显示特点，让元素符合布局要求)</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">效果</th>
<th style="text-align:center">使用频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">display: block</td>
<td style="text-align:center">转换为块级元素</td>
<td style="text-align:center">较多</td>
</tr>
<tr>
<td style="text-align:center">display: inline</td>
<td style="text-align:center">转换为行内元素</td>
<td style="text-align:center">较少</td>
</tr>
<tr>
<td style="text-align:center">display: inline-block</td>
<td style="text-align:center">转换为行内块元素</td>
<td style="text-align:center">较多</td>
</tr>
</tbody>
</table>
<p><strong>注：不允许 p 标签内嵌套 div、p、h 等块级元素。a 标签可以嵌套 a 以外的任意元素</strong></p>
<h3 id="emmet语法vs-code快速补充代码"><a class="markdownIt-Anchor" href="#emmet语法vs-code快速补充代码">#</a> emmet 语法 (vs code 快速补充代码)</h3>
<table>
<thead>
<tr>
<th style="text-align:center">使用</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标签名</td>
<td style="text-align:center">div</td>
<td style="text-align:center">&lt;div&gt;&lt;/div&gt;</td>
</tr>
<tr>
<td style="text-align:center">类选择器</td>
<td style="text-align:center">.red</td>
<td style="text-align:center">&lt;div class=“red”&gt;&lt;/div&gt;</td>
</tr>
<tr>
<td style="text-align:center">id 选择器</td>
<td style="text-align:center">#one</td>
<td style="text-align:center">&lt;div id=“one”&gt;&lt;/div&gt;</td>
</tr>
<tr>
<td style="text-align:center">交集选择器</td>
<td style="text-align:center">p.red#one</td>
<td style="text-align:center">&lt;p class=“red” id=“one”&gt;&lt;/p&gt;</td>
</tr>
<tr>
<td style="text-align:center">子代选择器</td>
<td style="text-align:center">ul&gt;li</td>
<td style="text-align:center">&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</td>
</tr>
<tr>
<td style="text-align:center">内部文本</td>
<td style="text-align:center" 内容="">ul&gt;li</td>
<td style="text-align:center">&lt;ul&gt;&lt;li &gt; 内容 &lt;/li&gt;&lt;/ul&gt;</td>
</tr>
<tr>
<td style="text-align:center">多个创建</td>
<td style="text-align:center">ul&gt;li*3</td>
<td style="text-align:center">&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</td>
</tr>
</tbody>
</table>
<h1 id="7css特性"><a class="markdownIt-Anchor" href="#7css特性">#</a> 7.CSS 特性</h1>
<h3 id="继承性inherit"><a class="markdownIt-Anchor" href="#继承性inherit">#</a> 继承性 (inherit)</h3>
<p><strong>子元素有默认继承父元素样式的特点</strong></p>
<p><strong>可以继承的常见属性 (文字控制属性都可以继承)</strong></p>
<p><strong>如：color font text line-height…</strong></p>
<p><strong>注：a 标签的 color 会继承失效，h 系列标签的 font-size 会继承失效</strong></p>
<h3 id="层叠性cascade"><a class="markdownIt-Anchor" href="#层叠性cascade">#</a> 层叠性 (cascade)</h3>
<p><strong>给同一个标签设置不同的样式，后语句会覆盖前语句</strong></p>
<p><strong>样式冲突时，只有选择器优先级相同时，才能通过层叠性判断结果</strong></p>
<h3 id="优先级priority"><a class="markdownIt-Anchor" href="#优先级priority">#</a> 优先级 (priority)</h3>
<p><strong>不同选择器具有不同的优先级，优先级高的选择器样式会覆盖优先级低的选择器样式</strong></p>
<p><strong>优先级公式：继承 &lt; 通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; id 选择器 &lt; 行内样式 &lt; !important</strong></p>
<p><strong>注：!important 写在属性值的后面，分号的前面。!imoprtant 不能提升继承的优先级，继承的优先级永远最低。实际开发不推荐使用</strong></p>
<h1 id="8盒子模型"><a class="markdownIt-Anchor" href="#8盒子模型">#</a> <mark>8. 盒子模型</mark></h1>
<p><strong>盒子尺寸 = width/height + 内边距 + 边框线</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">形式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">padding</td>
<td style="text-align:center">内边距。标签有默认内外边距，通常先清 0</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">border</td>
<td style="text-align:center">边框线</td>
<td style="text-align:center">border (- 方向): 10px solid red;(不分先后)</td>
</tr>
<tr>
<td style="text-align:center">margin</td>
<td style="text-align:center">外边距。margin 与 padding 无法改变行内标签的垂直位置</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">box-sizing: border-box</td>
<td style="text-align:center">使盒子尺寸 = width/height (内减模式)</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h1 id="9定位与装饰"><a class="markdownIt-Anchor" href="#9定位与装饰">#</a> <mark>9. 定位与装饰</mark></h1>
<h3 id="标准流-浮动-定位显示关系"><a class="markdownIt-Anchor" href="#标准流-浮动-定位显示关系">#</a> 标准流、浮动、定位显示关系</h3>
<p><mark><strong>标准流 &lt; 浮动 &lt; 定位</strong></mark></p>
<p><strong>默认情况下：同级定位下、后标签覆盖前标签</strong></p>
<p><strong>使用 z-index: int; 改变定位层数，默认为 0，数字越大，覆盖级别越高</strong></p>
<h3 id="一-写法"><a class="markdownIt-Anchor" href="#一-写法">#</a> <strong><mark>一、写法：</mark></strong></h3>
<p><strong>属性名：<mark>position</mark></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">定位方式</th>
<th style="text-align:center">属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">静态定位</td>
<td style="text-align:center">static</td>
</tr>
<tr>
<td style="text-align:center">相对定位</td>
<td style="text-align:center">relative</td>
</tr>
<tr>
<td style="text-align:center">绝对定位</td>
<td style="text-align:center">absolute</td>
</tr>
<tr>
<td style="text-align:center">固定定位</td>
<td style="text-align:center">fixed</td>
</tr>
</tbody>
</table>
<p><strong><mark>相对定位：</mark></strong></p>
<p><strong>1. 仍占有原来的位置。</strong></p>
<p><strong>2. 不脱标 (标准流)。</strong></p>
<p><strong>3. 改变位置参照自己原来的位置。</strong></p>
<p><strong>4. 不改变标签本身的显示模式 (块、行内、行内块)</strong></p>
<p><strong><mark>绝对定位：</mark></strong></p>
<p><strong>1. 如果有<mark>已经定位</mark>的父级元素，以该父级元素为参照物进行定位。若无，则以浏览器窗口为参照进行定位。</strong></p>
<p><strong>2. 脱标 (标准流)</strong></p>
<p><strong>3. 改变标签本身的显示模式、具备行内块的特点</strong></p>
<p><mark><strong>固定定位：</strong></mark></p>
<p><strong>1. 相对于浏览器进行定位移动。</strong></p>
<p><strong>2. 脱标 (标准流)</strong></p>
<p><strong>3. 位置随浏览器滚动而移动。</strong></p>
<p><strong>4. 改变标签本身的显示模式、具备行内块的特点</strong></p>
<p><strong>5.</strong></p>
<h3 id="二-偏移值"><a class="markdownIt-Anchor" href="#二-偏移值">#</a> <strong>二、偏移值</strong></h3>
<table>
<thead>
<tr>
<th style="text-align:center">方向</th>
<th style="text-align:center">属性名</th>
<th style="text-align:center">属性值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">水平</td>
<td style="text-align:center">left</td>
<td style="text-align:center">数字 + px</td>
<td style="text-align:center">距离左边的距离</td>
</tr>
<tr>
<td style="text-align:center">水平</td>
<td style="text-align:center">right</td>
<td style="text-align:center">数字 + px</td>
<td style="text-align:center">距离右边的距离</td>
</tr>
<tr>
<td style="text-align:center">垂直</td>
<td style="text-align:center">top</td>
<td style="text-align:center">数字 + px</td>
<td style="text-align:center">距离上边的距离</td>
</tr>
<tr>
<td style="text-align:center">垂直</td>
<td style="text-align:center">bottom</td>
<td style="text-align:center">数字 + px</td>
<td style="text-align:center">距离下边的距离</td>
</tr>
</tbody>
</table>
<p><strong>水平方向优先以 left 为准，垂直方向优先以 top 为准</strong></p>
<h3 id="三-装饰"><a class="markdownIt-Anchor" href="#三-装饰">#</a> 三、装饰</h3>
<h4 id="1对齐问题"><a class="markdownIt-Anchor" href="#1对齐问题">#</a> <mark><strong>1. 对齐问题：</strong></mark></h4>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">属性值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">vertical-align</td>
<td style="text-align:center">baseline</td>
<td style="text-align:center">默认，基线对齐</td>
</tr>
<tr>
<td style="text-align:center">用于处理标签对不齐</td>
<td style="text-align:center">top</td>
<td style="text-align:center">顶部对齐</td>
</tr>
<tr>
<td style="text-align:center">浏览器把行内和行内块标签当作文字处理</td>
<td style="text-align:center">middle</td>
<td style="text-align:center">中部对齐</td>
</tr>
<tr>
<td style="text-align:center">默认基线对齐</td>
<td style="text-align:center">bottom</td>
<td style="text-align:center">底部对齐</td>
</tr>
</tbody>
</table>
<h4 id="2光标指针"><a class="markdownIt-Anchor" href="#2光标指针">#</a> <strong>2. 光标指针：</strong></h4>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">属性值</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cursor</td>
<td style="text-align:center">default</td>
<td style="text-align:center">默认值，通常是箭头光标</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">pointer</td>
<td style="text-align:center">点击光标，提示用户可以点击</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">text</td>
<td style="text-align:center">工字光标，提示用户可以选择文字 / 输入内容</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">move</td>
<td style="text-align:center">十字光标，提示用户可以移动</td>
</tr>
</tbody>
</table>
<h4 id="3圆角边框"><a class="markdownIt-Anchor" href="#3圆角边框">#</a> <strong>3. 圆角边框：</strong></h4>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">border-radius</td>
<td style="text-align:center">数字 + px (圆角圆的半径)、百分比</td>
<td style="text-align:center">从左上角开始赋值、顺时针赋值、未赋值看对角</td>
</tr>
</tbody>
</table>
<p><strong>取值写 50% 为正圆 (盒子本身需要是正方形)、取值最大为 50%</strong></p>
<p><strong>取值写盒子高度的一半为胶囊 (盒子本身需要是长方形)</strong></p>
<h4 id="4溢出部分显示效果"><a class="markdownIt-Anchor" href="#4溢出部分显示效果">#</a> <strong>4. 溢出部分显示效果</strong></h4>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">属性值</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">overflow</td>
<td style="text-align:center">visible</td>
<td style="text-align:center">默认值，溢出部分可见</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hidden</td>
<td style="text-align:center">溢出部分隐藏</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">scroll</td>
<td style="text-align:center">无论是否溢出，都显示滚动条</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">auto</td>
<td style="text-align:center">根据是否溢出，自动显示或隐藏滚动条</td>
</tr>
</tbody>
</table>
<h4 id="5元素本身隐藏"><a class="markdownIt-Anchor" href="#5元素本身隐藏">#</a> 5. 元素本身隐藏</h4>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">visibility: hidden</td>
<td style="text-align:center">隐藏元素，仍占有元素位置 (使用较少)</td>
</tr>
<tr>
<td style="text-align:center">display: none</td>
<td style="text-align:center">隐藏元素，不占位 (使用较多)</td>
</tr>
</tbody>
</table>
<h4 id="6元素整体透明度"><a class="markdownIt-Anchor" href="#6元素整体透明度">#</a> 6. 元素整体透明度</h4>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">属性值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">opacity</td>
<td style="text-align:center">0-1 的数字</td>
<td style="text-align:center">1 完全不透明，0 完全透明</td>
</tr>
</tbody>
</table>
<h4 id="7精灵图"><a class="markdownIt-Anchor" href="#7精灵图">#</a> 7. 精灵图</h4>
<p><strong>作用：将多张小图合成为一张大图，一次发送给用户，减小服务器压力，提高页面加载速度</strong></p>
<p>新建一个盒子，将精灵图设置为盒子的背景图，使用 background-position 改变位置</p>
<h4 id="8盒子阴影"><a class="markdownIt-Anchor" href="#8盒子阴影">#</a> 8. 盒子阴影</h4>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">box-shadow</td>
<td style="text-align:center">h-shadow</td>
<td style="text-align:center">必填，水平位移量，允许负值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">v-shadow</td>
<td style="text-align:center">必填，垂直位移量，允许负值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">blur</td>
<td style="text-align:center">可选，模糊度</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">spread</td>
<td style="text-align:center">可选，阴影扩大</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">color</td>
<td style="text-align:center">可选，阴影颜色</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">inset</td>
<td style="text-align:center">可选，将阴影改为内部阴影</td>
</tr>
</tbody>
</table>
<h4 id="9过渡"><a class="markdownIt-Anchor" href="#9过渡">#</a> 9. 过渡</h4>
<p>作用：让元素样式缓慢变化，常配合 hover 使用，增强网页交互体验</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">取值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">transition</td>
<td style="text-align:center">过渡的属性</td>
<td style="text-align:center">all: 所有能过渡的属性都过渡、属性名 (如：width 只有 width 有过渡)</td>
</tr>
<tr>
<td style="text-align:center">加给变化的标签而非 hover</td>
<td style="text-align:center">过渡的时长</td>
<td style="text-align:center">数字 + s (秒)</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
</search>
